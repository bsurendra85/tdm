{"version":3,"sources":["./src/@tdm/ngx-dynamic-forms/src/core/decorators.ts","./src/@tdm/ngx-dynamic-forms/src/utils.ts","./src/@tdm/ngx-dynamic-forms/src/tdm-model-form/tdm-model-form.ts","./src/@tdm/ngx-dynamic-forms/src/tdm-model-form/tdm-model-form.service.ts","./src/@tdm/ngx-dynamic-forms/src/dynamic-forms/dynamic-form.component.ts","./src/@tdm/ngx-dynamic-forms/src/core/metadata/form-prop.ts","./src/@tdm/ngx-dynamic-forms/src/core/metadata/form-model.ts","./src/@tdm/ngx-dynamic-forms/src/core/angular-forms-mapper.ts","./src/@tdm/ngx-dynamic-forms/src/core/ng-forms-bound-mapper.ts","./src/@tdm/ngx-dynamic-forms/src/tdm-model-form/render-instruction.ts","./src/@tdm/ngx-dynamic-forms/src/create-control.ts","./src/@tdm/ngx-dynamic-forms/src/tdm-model-form/tdm-model-form.directive.ts","./node_modules/rxjs/_esm5/operator/toPromise.js","./src/@tdm/ngx-dynamic-forms/src/dynamic-forms/dynamic-form-override.directive.ts","./src/@tdm/ngx-dynamic-forms/src/dynamic-forms/before-render-event-handler.ts","./src/@tdm/ngx-dynamic-forms/src/dynamic-forms/dynamic-form-control.directive.ts","./src/@tdm/ngx-dynamic-forms/src/module.ts","./src/@tdm/ngx-dynamic-forms/src/dynamic-forms/dynamic-form.component.html"],"names":["FormModel","metaArgs","decorators_formModel","clone","control","value","result","esm5_forms","Array","isArray","controls","map","c","i","Object","tdm","keys","reduce","key","validator","setValidators","asyncValidator","setAsyncValidators","objectToForm","obj","plainMapper","_this","this","data","o","serialized_1","serialize","forEach","ctrl","serializePlain","addControl","getFormIsNotArrayErrorMessage","constructor","createRI","formProp","name","assign","parent","renderInstructions","render_instruction_RenderInstruction","render","required","createVRI","isPrimitive","isVirtual","virtualChildren","setDisplay","ri","display","_dSelf","_dParent","undefined","tryRunOnChildren","children","child","setDisplayParent","BASE_RENDERER","ordinal","Number","MAX_SAFE_INTEGER","form_prop_FormPropMetadata","_super","FormPropMetadata","info","target","call","create","transform","exclude","hasOwnProperty","defaultValue","validators","normValidators","asyncValidators","childForm","type","rtType","flatten","_i","_a","length","FormPropMetadata_1","tslib_es6","prototype","v","EMPTY","allowOn","extend","proxy","host","containerKey","form_model_FormModelMetadata","FormModelMetadata","props","Map","addProp","prop","ref","Boolean","String","Error","set","getProp","propertyKey","get","single","decorator","FormProp","on","processType","tMeta","getTargetMeta","modelProps","getMetaFor","formModel_1","asKeyValArray","getCreateProp","angular_forms_mapper_NgFormsDeserializeMapper","NgFormsDeserializeMapper","formGroup","sourceType","raw","formModel","getIdentity","identity","getKeys","filter","k","dirty","getValue","parseFormArray","parseFormGroup","deserializeFlattened","push","hasTarget","deserialize","getRawValue","mapper","deserializer","resultOrKey","len","forceSerialize","keys_1","childCtrl","p","angular_forms_mapper_NgFormsSerializeMapper","NgFormsSerializeMapper","container","cache","source","serializeCollection","serializeObject","forEachRaw","meta","createControl","cls","idKey","getIdentityKey","removeControl","ignoreArray","value_1","item","serializeChild","value_2","createFlatten","_b","value_3","getValidators","keys_2","flattenedControl","sync","slice","async","composeAsync","compose","angular_forms_mapper_NgFormsChildSerializeMapper","arr","s","path","concat","split","shift","typeMeta","propMeta","join","NgFormsChildSerializeMapper","ngFormsMapper","serializer","ng_forms_bound_mapper_NgFormsBoundDeserializeMapper","NgFormsBoundDeserializeMapper","instance","ng_forms_bound_mapper_NgFormsBoundMapper","NgFormsBoundMapper","fg","RenderInstruction","renderDef","hash","defineProperty","fullName","flattened","writable","markAsChanged","mergeData","getRuntimePath","root","name_1","indexOf","tdm_model_form_TDMModelForm","TDMModelForm","modelFormService","_model","_type","_ready","getInstructions","form","setValue","options","hasError","errorCode","appendControl","formArray","isNumberRe_1","pathArr","n","test","query","idx","removeAt","setContext","formMeta","getMeta","update","trackBy","commitToModel","onlyIfDirty","bindRenderingData","controlRenderer","renderData","tdmForm","fGroup","fArray","fControl","model","tdm_model_form_service_TDMModelFormService","TDMModelFormService","_getInstructions","tdmModelForm","createRICloneFactory","parentMap","riClone","rd","chilren","parent_1","getValues","instructions","props_1","localInstructions","parent_2","applyFlatten","renderInstruction","esm5_core","tdm_model_form_directive_TDMModelFormDirective","TDMModelFormDirective","selector","exportAs","toPromise","Observable","dynamic_form_override_directive_DynamicFormOverrideDirective","DynamicFormOverrideDirective","template","dynForm","find","dynamic_form_component_DynamicFormComponent","asyncUsed","done","before_render_event_handler_BeforeRenderEventHandler","BeforeRenderEventHandler","notify","DynamicFormComponent","tdmModelFormService","kvDiffers","itDiffers","renderer","valueChanges","beforeRender","BehaviorSubject","subscriptions","stateDiffer","rendering$","_ngNativeValidate","overrideMap","arrayActionRequest$","pendingUpdates","codeOverrides","renderState","asObservable","arrayActionRequest","native","setNativeValidation","slaveMode","valueDiffer","formValue","diff","applyFormListener","redraw","returnPromise","Promise","resolve","pipe","operators","state","getOverride","ngOnChanges","changes","hotBind","onStateChange","disabledState","hiddenState","ngDoCheck","handleDiff","disabled","hidden","ngAfterContentInit","afterInit","updateOverrides","overrides","subscribe","ngAfterViewInit","ngOnDestroy","subs","pop","unsubscribe","complete","getControl","addOverride","tRef","d","dynamicFormOverride","wildOverride","emitArrayActionRequest","request","runtimePath","emit","match","ow","controlsReady","setTimeout","emitRenderingState","controlsMap","clear","toArray","excluded","fullPath","isStaticPathContainsPath","override","renderEvent","all","catch","err","then","next","sort","a","b","pathList","findIndex","nextChar","freeze","freezeValueChanges","arr_1","forEachChangedItem","change","currentValue","isFlattenedProp","apply","drillDownChange","level","some","r","previousValue","differ","deep","formElRef","removeAttribute","nativeElement","setAttribute","forEachAddedItem","record","disable","forEachRemovedItem","enable","findRenderInstructionByKey","dotProperty","substr","FORM_CONTROL_COMPONENT","dynamic_form_control_directive_DynamicFormControlDirective","DynamicFormControlDirective","vcRef","component","injector","parentInjector","componentFactory","resolveComponentFactory","$implicit","createEmbeddedView","cmpRef","createComponent","tdmOnControlContextInit","module_DynamicFormsModule","DynamicFormsModule","forRoot","formComponent","ngModule","DynamicFormsModule_1","providers","provide","multi","useValue","forChild","declarations","imports","common","exports","TDMFormsModule","module"],"mappings":"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","file":"common.9d30d565d3a0cac5c7b9.chunk.js","sourcesContent":["import { targetStore, MapExt, Constructor, MetaClass, MetaClassInstanceDetails } from '@tdm/core/tdm';\nimport {\n  FormModelMetadata,\n  FormModelMetadataArgs,\n  FormPropMetadata,\n  FormPropMetadataArgs // leave for angular AOT compiler.\n} from './metadata/index';\n\n/** @internal */\nexport let formModel: any = {};\nformModel = MetaClass.decorator(FormModelMetadata, true);\n\n/**\n * @propertyDecorator static\n * @param metaArgs\n */\nexport function FormModel(metaArgs?: FormModelMetadataArgs): (target: Function) => any {\n  return formModel(metaArgs) as any;\n}\n\n/**\n * @propertyDecorator instance\n * @param metaArgs\n */\nexport const FormProp = MetaClass.decorator(FormPropMetadata, true);\n\ntargetStore.on\n  .processType((target: Constructor<any>) => {\n    const tMeta = targetStore.getTargetMeta(target);\n    const modelProps = tMeta.getMetaFor(FormPropMetadata);\n    if (modelProps) {\n      let formModel = tMeta.getMetaFor(FormModelMetadata, true);\n      if (!formModel) {\n        FormModel()(target);\n        formModel = tMeta.getMetaFor(FormModelMetadata, true);\n      }\n\n      MapExt.asKeyValArray(modelProps)\n        .forEach(([k, v]) => {\n          formModel.addProp(tMeta.getCreateProp(k as any), v, target);\n        });\n    }\n  });\n\n\n\n// WEBPACK FOOTER //\n// ./src/@tdm/ngx-dynamic-forms/src/core/decorators.ts","import { isJsObject, isPrimitive, PlainObjectMapper } from '@tdm/core/tdm';\nimport { AbstractControl, FormArray, FormGroup, FormControl } from '@angular/forms';\n\n/**\n * Performs a FormArray deep clone.\n * Does not clone state.\n * Does not clone values but can assign if a value is supplied.\n * Does clone sync and async validators.\n */\nexport function clone(control: FormArray, value?: any[]): FormArray;\n/**\n * Performs a FormGroup deep clone.\n * Does not clone state.\n * Does not clone values but can assign if a value is supplied.\n * Does clone sync and async validators.\n */\nexport function clone(control: FormGroup, value?: any): FormGroup;\nexport function clone(control: FormArray | FormGroup | FormControl,\n                      value?: any | any[]): FormArray | FormGroup | FormControl {\n  let result: FormArray | FormGroup | FormControl;\n  if (control instanceof FormControl) {\n    result = new FormControl(value);\n  } else if (control instanceof FormArray) {\n    value = Array.isArray(value) ? value : [];\n    result = new FormArray(control.controls.map( (c, i) => clone(control, value[i])));\n  } else if (control instanceof FormGroup) {\n    value = isJsObject(value) ? value : {};\n    const keys = Object.keys(control.controls);\n    result = new FormGroup(keys.reduce( (controls, key) => {\n      controls[key] = clone(<any> control.controls[key], value[key]);\n      return controls;\n    }, {} as { [key: string]: AbstractControl }));\n  }\n  if (control.validator) {\n    result.setValidators(control.validator);\n  }\n  if (control.asyncValidator) {\n    result.setAsyncValidators(control.asyncValidator);\n  }\n  return result;\n}\n\n/**\n * Converts a plain object (POJO) to a FormGroup or an array of plain object to FormArray\n */\nexport function objectToForm(obj: any, plainMapper?: PlainObjectMapper): FormGroup | FormArray {\n  if (!plainMapper) {\n    plainMapper = new PlainObjectMapper();\n  }\n\n  let data: FormGroup | FormArray;\n  if (Array.isArray(obj)) {\n    data = new FormArray(obj.map(o => objectToForm(o)));\n  } else {\n    data = new FormGroup({});\n    const serialized = plainMapper.serialize(obj);\n\n    Object.keys(serialized)\n      .forEach(key => {\n        const value = serialized[key];\n        let ctrl = isPrimitive(value)\n          ? new FormControl(value)\n          : this.serializePlain(value)\n        ;\n        (data as FormGroup).addControl(key, ctrl);\n      });\n  }\n  return data;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/@tdm/ngx-dynamic-forms/src/utils.ts","import { Type } from '@angular/core';\nimport { AbstractControl, FormGroup, FormArray, FormControl } from '@angular/forms';\n\nimport { stringify, isNumber } from '@tdm/core/tdm';\nimport { FormModelMetadata, NgFormsBoundMapper } from '../core/index';\nimport { TDMModelFormService } from './tdm-model-form.service';\nimport { RenderInstruction } from './render-instruction';\nimport { createControl } from '../create-control';\n\nexport interface DynamicFormControlRenderer {\n  item: RenderInstruction;\n  tdmForm: TDMModelForm<any>;\n  fArray: FormArray | undefined;\n  fControl: FormControl | undefined;\n  fGroup: FormGroup | undefined;\n\n  tdmOnControlContextInit?(): void ;\n}\n\nfunction getFormIsNotArrayErrorMessage(value: AbstractControl | undefined): string {\n  const got = value ? 'undefined' : stringify(value.constructor);\n  return `A control can only be added to a form array instance, got ${ got }`;\n}\n\n/**\n * A container that binds a model instance and and a `FormGroup` instance.\n *\n * This class is a facade, it simplifies the logic and low level operations required to bind a model\n * and a form:\n *   - mapping between model and form (serialization and deserialization)\n *   - exposing rendering instructions for a model (the instructions are used to render form elements)\n */\nexport class TDMModelForm<T = any> {\n\n  form: FormGroup;\n\n  get model(): T {\n    return this._model;\n  }\n\n  get type(): Type<T> {\n    return this._type;\n  }\n\n  get ready(): boolean {\n    return this._ready;\n  }\n  /**\n   * The render instructions for the TDMModel type of this instance.\n   * @returns\n   */\n  get renderData(): RenderInstruction[] {\n    return this.modelFormService.getInstructions(this.type);\n  }\n\n  private mapper: NgFormsBoundMapper<any>;\n  private formMeta: FormModelMetadata;\n  private _type: Type<T>;\n  private _model: T;\n  private _ready: boolean;\n\n  constructor(protected modelFormService: TDMModelFormService) { }\n\n  /**\n   * Returns the control for from the provided `path`.\n   *\n   * > This is method is just sugar for `tDMModelFormInstance.form.get(path)`\n   *\n   * @param path The path, relative to the root form. Accepts the same types as `AbstractControl.get`.\n   * See {@link https://angular.io/api/forms/AbstractControl#get}\n   */\n  get(path: Array<string | number> | string): AbstractControl | null {\n    return this.form.get(path);\n  }\n\n  /**\n   * Gets's a value from the provided `path`.\n   *\n   * > This is method is just sugar for `tDMModelFormInstance.form.get(path).value`\n   *\n   * @param path The path, relative to the root form. Accepts the same types as `AbstractControl.get`.\n   * See {@link https://angular.io/api/forms/AbstractControl#get}\n   */\n  getValue(path: Array<string | number> | string): any | null {\n    const c = this.form.get(path);\n    return c ? c.value : null;\n  }\n\n  /**\n   * Set's the provided `value` in the provided `path`. The path is applied from the root form.\n   *\n   * > This is method is just sugar for `tDMModelFormInstance.form.get(path).setValue(value)`\n   *\n   * @param path The path, relative to the root form. Accepts the same types as `AbstractControl.get`.\n   * See {@link https://angular.io/api/forms/AbstractControl#get}\n   * @param value The value to apply on the control retrieved from path\n   * @param options\n   */\n  setValue(path: Array<string | number> | string, value: any, options?: any): void {\n    this.form.get(path).setValue(value, options);\n  }\n\n  hasError(errorCode: string, path: keyof T): boolean {\n    return this.form.hasError(errorCode, path as any);\n  }\n\n  /**\n   * Adds a new form control to a FormArray instance at the provided path.\n   *\n   * This is a utility method for easy add/remove operations on UI form's with a FormArray instance.\n   *\n   * @param path The path, relative to the root form. Accepts the same types as `AbstractControl.get`.\n   * See {@link https://angular.io/api/forms/AbstractControl#get}\n   * @param value An existing value that represents the value of the new form control, if not set the form control will\n   * have no value (i.e. represents a new instance of the model).\n   */\n  appendControl(path: Array<string | number> | string, value?: any): FormGroup | FormControl {\n    const formArray = this.form.get(path);\n    if (formArray instanceof FormArray) {\n      const isNumberRe = /^\\d+$/;\n      // we got the instance, now move to type metadata world where all array index references, if exist, must go out.\n      const pathArr = Array.isArray(path)\n        ? path.filter( n => !isNumber(n) )\n        : path.split('.').filter( v => !isNumberRe.test(v) )\n      ;\n      const ctrl = createControl(this.type, [<any> pathArr.shift(), pathArr.join('.')], value);\n      formArray.push(ctrl);\n      return ctrl;\n    } else {\n      throw new Error(getFormIsNotArrayErrorMessage(formArray));\n    }\n  }\n\n  /**\n   * Removes a form control in the provided index from a FormArray instance at the provided path.\n   *\n   * This is a utility method for easy add/remove operations on UI form's with a FormArray instance.\n   *\n   * @param path The path, relative to the root form. Accepts the same types as `AbstractControl.get`.\n   * See {@link https://angular.io/api/forms/AbstractControl#get}\n   * @param query The index at the form array to remove at or a form control instance to remove from the form array.\n   * @returns The removed control or undefined if nothing was removed.\n   */\n  removeControl(path: Array<string | number> | string, query: number | AbstractControl): AbstractControl | undefined {\n    const formArray = this.form.get(path);\n    if (formArray instanceof FormArray) {\n      const idx = isNumber(query) ? query : formArray.controls.indexOf(query);\n      const ctrl = formArray.controls[idx];\n      if (ctrl) {\n        formArray.removeAt(idx);\n      }\n      return ctrl;\n    } else {\n      throw new Error(getFormIsNotArrayErrorMessage(formArray));\n    }\n  }\n\n  /**\n   * Set the context for this the form.\n   * @param instance The TDModel instance\n   * @param type The TDModel class, if not set instance.constructor is the default.\n   */\n  setContext(instance: T, type?: Type<T>) {\n    if (!type) {\n      type = <any> instance.constructor;\n    }\n\n    if (this._model === instance && this._type === type) {\n      return;\n    }\n\n    if (this._type !== type) {\n      this.formMeta = this.modelFormService.getMeta(type);\n      this._type = type;\n    }\n\n    if (this._model !== instance) {\n      this._model = instance;\n    }\n\n    this.update();\n  }\n\n  /**\n   * A helper function for an *ngFor \"trackBy\" handler.\n   * > It is not recommended to change the trackBy logic when using `dynamic-form` component, the change detection logic\n   * is based on it.\n   * @param idx\n   * @param item\n   * @returns\n   */\n  trackBy(idx: number, item: RenderInstruction): any {\n    return item.hash;\n  }\n\n  /**\n   * Commit the form data into the model instance. (deserialize)\n   *\n   * Note that the response might be true even if the form was not dirty.\n   * The response is always true when onlyIfDirty === false.\n   * If onlyIfDirty is true and the form is NOT dirty, only then the response is false.\n   *\n   * @param onlyIfDirty if true will commit only if the form is dirty\n   * @returns Did it commit (deserialize)\n   */\n  commitToModel(onlyIfDirty?: boolean): boolean {\n    if (onlyIfDirty === true && !this.form.dirty) {\n      return false;\n    }\n    this.mapper.deserialize();\n    return true;\n  }\n\n  bindRenderingData(controlRenderer: DynamicFormControlRenderer,\n                    renderData: RenderInstruction): void {\n    controlRenderer.tdmForm = this;\n    controlRenderer.fGroup = renderData.flattened\n      ? this.form.get(renderData.flattened) as FormGroup\n      : this.form\n    ;\n    if (renderData.isArray) {\n      controlRenderer.fArray = <any> controlRenderer.fGroup.get(renderData.name);\n    } else {\n      controlRenderer.fControl = <any> controlRenderer.fGroup.get(renderData.name);\n    }\n    controlRenderer.item = renderData;\n  }\n\n  protected update(): void {\n    if (this._type && this._model) {\n      this.mapper = new NgFormsBoundMapper(this._type, this.model);\n      this.form = this.mapper.serialize();\n      this._ready = true;\n    } else {\n      this.mapper = this.form = undefined;\n      this._ready = false;\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/@tdm/ngx-dynamic-forms/src/tdm-model-form/tdm-model-form.ts","import { Injectable, Type } from '@angular/core';\nimport { targetStore, PropMetadata } from '@tdm/core/tdm';\nimport { TDMModelForm } from './tdm-model-form';\nimport { RenderInstruction } from './render-instruction';\n\nimport { BASE_RENDERER, FormModelMetadata, FormPropMetadata } from '../core/index';\n\nfunction createRI(formProp: FormPropMetadata,\n                  name: string,\n                  assign: any,\n                  parent?: RenderInstruction): RenderInstruction {\n  const renderInstructions = new RenderInstruction(formProp.render, name, parent);\n  if (formProp.required) {\n    renderInstructions.required = true;\n  }\n  Object.assign(renderInstructions, assign);\n  return renderInstructions;\n}\n\nfunction createVRI(formProp: FormPropMetadata,\n                   name: string,\n                   parent?: RenderInstruction): RenderInstruction {\n  return createRI(formProp, name, { isPrimitive: false, isVirtual: true, virtualChildren: [] }, parent);\n}\n\n/**\n * A service for creating new instances of TDMModelForm\n */\n@Injectable()\nexport class TDMModelFormService {\n  private cache = new Map<Type<any>, RenderInstruction[]>();\n\n  getMeta(type: Type<any>): FormModelMetadata {\n    return type\n      ? targetStore.getMetaFor(type, FormModelMetadata, true)\n      : undefined\n    ;\n  }\n\n  getInstructions(type: Type<any>): RenderInstruction[] {\n    return this.cache.get(type) || this._getInstructions(type);\n  }\n\n  create<T>(instance: T, type?: Type<T>): TDMModelForm<T> {\n    const tdmModelForm = new TDMModelForm<T>(this);\n    tdmModelForm.setContext(instance, type);\n    return tdmModelForm;\n  }\n\n  /**\n   * Returns a clone function for cloning [[RenderInstruction]] instances.\n   * The clone function returned can be used to clone a single cycle of instructions returned from\n   * [[TDMModelFormService.getInstructions]] so create a new clone function for each iteration cycle.\n   *\n   * We need to clone [[RenderInstruction]] because they represent metadata while a form represents a single instance\n   * that re-occurs thus can not change the metadata and must use a copy.\n   * Instead of recreating the metadata over and over we just use JS's prototype to create layers over the metadata that\n   * act as instances while not duplicating the data.\n   */\n  createRICloneFactory<T extends RenderInstruction>(): (ri: RenderInstruction) => T {\n    // We clone a [[RenderInstruction]] by creating a new layer in the prototype chain so the current layer can not be\n    // changed by assigning but can be used when retrieving, this saves space and time.\n    // Usually Object.create() is the only thing we need but there are 2 special cases: Arrays and `flatten` expressions\n    // Array's and `flatten` expressions (virtual rendering instruction) which requires special attention.\n    //\n    // Array's represent a [[RenderInstruction]] for a property of type Array<T> where the [[RenderInstruction]]\n    // instance represents the array and the `children` property in it represents a list of [[RenderInstruction]]\n    // instances representing T. The children are not part of the rendering instructions, only the array it self so when\n    // cloning the children are not cloned so we need to handle them internally.\n    //\n    // Virtual's (flatten expressions) represent a form group which get's converted into a list of [[RenderInstruction]]\n    // instances with the virtual as parent but the virtual itself is never a part of the instructions.\n    // So, when cloning, we also need to clone the virtual but we need to make sure not to clone it multiple times as\n    // next call's will be from another child of the same virtual. We do that by using a map to make sure we are\n    // cloning a virtual one time only. This is why a clone function is good for one cycle.\n\n    // map for storing used virtual's\n    const parentMap = new Map<any, any>();\n\n    const riClone = rd => {\n      rd = Object.create(rd);\n      if (rd.isArray) {\n        rd.chilren = rd.children.map( c =>  {\n          c = riClone(c);\n          c.parent = rd;\n          return c;\n        });\n      } else if (rd.parent && rd.parent.isVirtual) {\n        let parent = parentMap.get(rd.parent);\n        if (!parent) {\n          parent = riClone(rd.parent);\n          parent.virtualChildren = [];\n          parentMap.set(rd.parent, parent);\n        }\n        rd.parent = parent;\n        parent.virtualChildren.push(rd);\n      }\n      return rd;\n    };\n    return riClone;\n  }\n\n  private _getInstructions(type: Type<any>): RenderInstruction[] {\n    // NOTE: The logic for creating instructions is tightly coupled with the logic for cloning the instructions.\n    //       Make sure changes in the logic are reflected in `createRICloner()`\n    const props = targetStore.getTargetMeta(type).getValues(PropMetadata);\n    const formMeta = this.getMeta(type);\n    const instructions: RenderInstruction[] = [];\n    for (let p of props) {\n      const formProp = formMeta.getProp(p.name as string);\n      if (!formProp) {\n        instructions.push(new RenderInstruction(BASE_RENDERER, p.name as string));\n      } else if (!formProp.exclude) {\n        const typeMeta = formProp.rtType || p.type;\n\n        let localInstructions: RenderInstruction[] = instructions;\n        let name: PropertyKey  = p.name;\n        let parent: RenderInstruction;\n        const isPrimitive = !(formProp.flatten || formProp.childForm);\n        if (typeMeta && typeMeta.isArray) {\n          parent = createRI(formProp, name as string, { isArray: true, isPrimitive, children: localInstructions = [] });\n          instructions.push(parent);\n        }\n\n        if (formProp.flatten) {\n          this.applyFlatten(\n            formProp.flatten,\n            [name as string],\n            localInstructions,\n            createVRI(formProp, name as string, parent)\n          );\n        } else {\n          localInstructions.push(createRI(formProp, name as string, { isPrimitive }, parent));\n        }\n      }\n    }\n    return instructions;\n  }\n\n  private applyFlatten(props: { [keys: string]: FormPropMetadata },\n                       path: Array<string | number>,\n                       instructions: RenderInstruction[],\n                       parent: RenderInstruction): void {\n    for (let key of Object.keys(props)) {\n      const p = props[key];\n      if (p.flatten) {\n        this.applyFlatten(p.flatten, path.concat([key]), instructions, createVRI(p, key, parent));\n      } else {\n        const isPrimitive = !p.childForm;\n        const renderInstruction = createRI(p, key as string, { isPrimitive, flattened: path }, parent);\n        parent.virtualChildren.push(renderInstruction);\n        instructions.push(renderInstruction);\n      }\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/@tdm/ngx-dynamic-forms/src/tdm-model-form/tdm-model-form.service.ts","import { Observable } from 'rxjs/Observable';\nimport { BehaviorSubject } from 'rxjs/BehaviorSubject';\nimport { Subscription } from 'rxjs/Subscription';\nimport { toPromise } from 'rxjs/operator/toPromise';\nimport { filter } from 'rxjs/operators';\n\nimport {\n  Component,\n  Input,\n  EventEmitter,\n  Output,\n  ContentChildren,\n  QueryList,\n  AfterContentInit,\n  OnDestroy,\n  Type,\n  TemplateRef,\n  IterableChanges,\n  IterableDiffer,\n  IterableDiffers,\n  KeyValueDiffer,\n  KeyValueDiffers,\n  KeyValueChangeRecord, ElementRef, ViewChild, Renderer2, AfterViewInit, DoCheck, OnChanges, SimpleChanges, SimpleChange\n} from '@angular/core';\nimport { AbstractControl, FormGroup } from '@angular/forms';\n\nimport { Omit } from '@tdm/core/tdm';\nimport { TDMModelForm, TDMModelFormService, RenderInstruction } from '../tdm-model-form/index';\nimport { DynamicFormOverrideDirective, DynamicFormOverrideContext } from './dynamic-form-override.directive';\nimport { BeforeRenderEventHandler } from './before-render-event-handler';\nimport {\n  ArrayActionRequestEvent,\n  ArrayActionAddRequestEvent,\n  ArrayActionMoveRequestEvent,\n  ArrayActionRemoveRequestEvent\n} from './array-action-request';\n\nexport interface LocalRenderInstruction extends RenderInstruction {\n  /**\n   * Used to show/hide controls\n   * @internal\n   */\n  display: 'none' | undefined;\n\n  /**\n   * Used as flag for show/hide (true is hide)\n   * @internal\n   */\n  _dSelf: boolean;\n  /**\n   * Used as flag for show/hide of parent (true is hide)\n   * @internal\n   */\n  _dParent: boolean;\n}\n\n/**\n * Represents a single change in a form.\n * This type is an alias of KeyValueChangeRecord<string, any>\n */\nexport interface TdmFormChange extends KeyValueChangeRecord<string, any> {\n  /**\n   * When true indicates that the `key` property contains a path and not a name, i.e it's a dot delimited path to a\n   * property through nested object (or objects)\n   */\n  deep?: boolean;\n}\n\n/**\n * Represents a collection of changes in a form\n * This type is an alias of Array<KeyValueChangeRecord<string, any>> (TdmFormChange[])\n */\nexport type TdmFormChanges = TdmFormChange[];\n\ntype StateKeys = 'exclude' | 'disabled' | 'hidden';\n\n/**\n * Allow rendering a form using @tdm/ngx-dynamic-forms and DynamicFormElementComponent\n */\n@Component({\n  selector: 'dynamic-form',\n  templateUrl: './dynamic-form.component.html'\n})\nexport class DynamicFormComponent<T = any> implements AfterContentInit, AfterViewInit, OnChanges, DoCheck, OnDestroy {\n  /**\n   * The [[TDMModelForm]] instance that is used by the component\n   * > This is created after a model is set.\n   */\n  tdmForm: TDMModelForm<any>;\n\n  /**\n   * The [[FormGroup]] instance used by [[TDMModelForm]].\n   * Available after [[TDMModelForm]] instance is created.\n   */\n  get form(): FormGroup | undefined {\n    return this.tdmForm && this.tdmForm.form;\n  }\n\n  @ContentChildren(DynamicFormOverrideDirective) overrides: QueryList<DynamicFormOverrideDirective>;\n\n  @ViewChild('formElRef') formElRef: ElementRef;\n\n  /**\n   * Real time binding between the form and the model.\n   *\n   * When true, every value change event emitted from the from will trigger and update to the model.\n   *\n   * When false (default) the form data model and the model instance are not bound, to update the model\n   * you need to invoke the TDMModelForm.commitToModel\n   *\n   * > A hot bind is one way, from form update to the model.\n   *\n   * @default false\n   */\n  @Input() hotBind: boolean;\n\n  /**\n   * A expression to apply on the form control container class.\n   *\n   * Use as if this was an `ngClass` directive.\n   *\n   * > The class will apply on the container that wraps the rendered control and not on the control itself.\n   */\n  @Input() controlClass: string|string[]|Set<string>|{[klass: string]: any};\n\n  /**\n   * Pass through for @angular/forms `ngNativeValidate` attribute that enables native browser validation\n   *\n   */\n  @Input() get ngNativeValidate(): any { return this._ngNativeValidate; };\n  set ngNativeValidate(value: any) { // tslint:disable-line\n    const native = value != null && `${value}` !== 'false';\n    if (this._ngNativeValidate !== native) {\n      this._ngNativeValidate = native;\n      this.setNativeValidation();\n    }\n  };\n\n  /**\n   * The instance and type (class) to dynamically render as form.\n   * You can supply the instance only, in that case the type is the constructor property (instance.constructor)\n   * To supply both instance and type use a tuple.\n   *\n   * @example\n   * `<dynamic-form [model]=\"user\"></dynamic-form>`\n   * `<dynamic-form [model]=\"[user, User]\"></dynamic-form>`\n   *\n   * @param value {*|[*, *]}\n   */\n  @Input() set model(value: T | [T, Type<T>]) {\n    if (this.slaveMode) {\n      throw new Error('Setting a model is not allowed when in slave mode.');\n    }\n    this.slaveMode = false;\n\n    const [instance, type] = Array.isArray(value) ? value : [value, <any> value.constructor];\n    this.instance = instance;\n    this.type = type;\n\n    this.valueDiffer = undefined;\n\n    if (!this.tdmForm) {\n      this.tdmForm = this.tdmModelFormService.create(this.instance, this.type);\n      const formValue = this.tdmForm.form.getRawValue();\n      this.valueDiffer = this.kvDiffers.find(formValue).create();\n      this.valueDiffer.diff(formValue); // for some reason objects do not commit the 1st time\n      this.applyFormListener();\n    } else {\n      this.tdmForm.setContext(this.instance, this.type);\n    }\n    this.update();\n  }\n\n  /**\n   * Setting the dynamic form as a slave of another dynamic form.\n   * You can this feature to split forms of complex models.\n   *\n   * A form in slave mode has very limited functionality, it can only exclude controls and override controls.\n   * All other options (hidden state, disabled state, hot binding etc..) are not supported in the slave and should be\n   * handled in the master.\n   *\n   * Make sure you are not rendering the same controls more then once. A group of master and all of it's slave should\n   * render only one instance of a control across the whole group. If you render the same control multiple times\n   * you will get unexpected behaviour and unsynced controls.\n   *\n   * You can set any number of slaves.\n   * You can not change or remove the master.\n   * You can not set a model when using slave mode.\n   *\n   * A slave does not handle form state, it only handles internal rendering and this is why only exclude and override\n   * are supported, hidden and disabled are drived by the form state...\n   * @param dynForm\n   */\n  @Input() set slaveOf(dynForm: DynamicFormComponent<T>) {\n    if (this.slaveMode === true) {\n      return; // TODO: warn? error? slave mode can only be set once.\n    } else if (this.slaveMode === false) {\n      throw new Error('Slave mode does not work when setting a model');\n    }\n    this.tdmForm = dynForm.tdmForm;\n    this.instance = dynForm.instance;\n    this.type = dynForm.type;\n    this.slaveMode = true;\n  }\n\n  /**\n   * An array of form control names, each name in this array will not be rendered (excluded).\n   * Supports deep paths using dot notation.\n   * The end result in the UI is identical to `hiddenState` however excluded fields behave like `*ngIf`, they are never\n   * rendered, hidden fields are rendered but not displayed.\n   */\n  @Input() exclude: string[];\n\n  /**\n   * An array of form control names, each name in this array will be disabled.\n   * Supports deep paths using dot notation.\n   */\n  @Input() disabledState: string[];\n\n  /**\n   * An array of form control names, each name in this array will be hidden.\n   * Supports deep paths using dot notation.\n   * The end result in the UI is identical to `exclude` however excluded fields behave like `*ngIf`, they are never\n   * rendered, hidden fields are rendered but not displayed.\n   */\n  @Input() hiddenState: string[];\n\n  /**\n   * Event emitted when a form value changes.\n   *\n   * When a change occurs in a child property of a flattened property (nested objects) the `key` property in the change\n   * represents a path (not the name) to the value from the root object.\n   *\n   * > Note that each event is emitted synchronously and all listeners will run in sequence. While listeners run new\n   * change events are blocked which means you can change form values without the event firing again. If you do want\n   * a re-fire change the value async.\n   */\n  @Output() valueChanges = new EventEmitter<TdmFormChanges>();\n\n  /**\n   * Event emitted before rendering form controls.\n   *\n   *   - Excluded controls are not emitted.\n   *\n   * Use this event to modify form control/s rendering instructions (metadata) before they are rendered.\n   * For example, given a `select` form control, you can use this event to create dynamic, ad-hoc, select options.\n   *\n   * ```html\n   *  <dynamic-form [model]=\"model\" (beforeRender)=\"beforeRender($event)\">\n   * ```\n   *\n   * ```ts\n   * @Component({ ... })\n   * export class MyComponent {\n   *   beforeRender(event: BeforeRenderEventHandler) {\n   *     if ('state' in event.instructions) {\n   *       event.instructions.state.options = [ { value: 'X', label: 'Y' } ] // more...\n   *     }\n   *   }\n   * }\n   * ```\n   * You can modify all the of properties in {@link RenderInstruction}... the render type, order and more.\n   *\n   * ### Asynchronous rendering logic\n   * There are scenarios where the modification logic is asynchronous, for example, populating the\n   * options (options) of a form control from a remote server\n   *\n   * ```ts\n   * @Component({ ... })\n   * export class MyComponent {\n   *   beforeRender(event: BeforeRenderEventHandler) {\n   *     if ('state' in event.instructions) {\n   *       let resolve, p = new Promise( (res, rej) => { resolve = res; });\n   *\n   *       event.async(p); // notify to use async logic\n   *\n   *       // do some async stuff...\n   *       setTimeout(() => {\n   *         event.instructions.state.options = [ { value: 'X', label: 'Y' } ] // more...\n   *         resolve();\n   *       }, 1000);\n   *     }\n   *   }\n   * }\n   * ```\n   * > You can use the `renderState` event to reflect asynchronous rendering in the UI.\n   */\n  @Output() beforeRender = new EventEmitter<BeforeRenderEventHandler>();\n\n  /**\n   * Event emitted when the rendering state changes.\n   * True states that the form is rendering, False states and idle, the form is rendered.\n   *\n   * Since rendering in angular is synchronous a True rendering state can only occur when implementing\n   * async logic within `beforeRender` event {@link BeforeRenderEventHandler}\n   *\n   * Use this event to reflect (UX/UI) in that the form is not ready.\n   */\n  @Output() renderState: Observable<boolean>;\n\n  /**\n   * Event emitted when an internal request to add/remove/move an item from a [[FormArray]] is submitted.\n   * Array actions request are not managed by the library, this API exists to allow flexibility when handling\n   * form arrays.\n   *\n   * Components that implement [[DynamicFormControlRenderer]] and are set to be used by <dynamic-form> are responsible\n   * for array action request submission.\n   * This is because they implement the way a form array looks, they might implement multiple list styles some editable\n   * and some not. They encapsulate buttons and so have access to click events.\n   * These components must implement [[DynamicFormControlRenderer]] and so they have access to the API.\n   *\n   * An implementation might choose to emit events so handlers on the outside can handle the logic for add/remove/move\n   * or it can be a local implementation without exposing events, this is up to the developer.\n   *\n   * This event should be treated as external and handled by the developer.\n   *\n   * > Developers should use the `emitArrayActionRequest` method in this class to invoke events, the method requires a\n   * partial event object as input and will complete the missing information.\n   */\n  @Output() arrayActionRequest: Observable<ArrayActionRequestEvent>;\n\n  /**\n   * The active render instructions for this instance, active instructions does not include excluded instruction.\n   */\n  instructions: { [path: string]: RenderInstruction } = {};\n\n  /**\n   * The active render instructions for this instance, active instructions does not include excluded instruction.\n   * @internal\n   */\n  controls = new BehaviorSubject<LocalRenderInstruction[]>([]);\n\n  private instance: T;\n  private type: Type<T>;\n  private subscriptions: Subscription[] = [];\n  private freezeValueChanges: boolean;\n  private valueDiffer: KeyValueDiffer<string, any>;\n  private stateDiffer: Partial<Record<StateKeys, IterableDiffer<string>>> = {};\n  private afterInit: boolean;\n  private rendering$ = new BehaviorSubject<boolean>(false);\n  private _ngNativeValidate: any = false;\n  private slaveMode: boolean;\n  private overrideMap = new Map<RenderInstruction, DynamicFormOverrideDirective>();\n  private wildOverride: DynamicFormOverrideDirective;\n  private arrayActionRequest$ = new EventEmitter<ArrayActionRequestEvent>();\n  private renderInstructions: RenderInstruction[];\n\n  /**\n   * Indicates the number of update() calls that are running/queued\n   * A number n that is > 1 does not mean the update will run n times, it will run one more time only.\n   */\n  private pendingUpdates: number = 0;\n  /**\n   * Overrides that are injected by code (addOverride) and not by content projection\n   */\n  private codeOverrides: DynamicFormOverrideDirective[] = [];\n\n  constructor(private tdmModelFormService: TDMModelFormService,\n              private kvDiffers: KeyValueDiffers,\n              private itDiffers: IterableDiffers,\n              private renderer: Renderer2) {\n    this.renderState = this.rendering$.asObservable();\n    this.arrayActionRequest = this.arrayActionRequest$.asObservable();\n  }\n\n  /**\n   * Redraw the controls of the form.\n   * This will fire the (renderState) event and trigger (beforeRender) event's for each render instruction.\n   *\n   * If you wish to invoke a silent update call the markAsChanged() method on a [[RenderInstruction]] instance, this\n   * will mark it for change detection but will not fire the events.\n   */\n  redraw(): void;\n  redraw(returnPromise: boolean): Promise<void>;\n  redraw(returnPromise?: boolean): Promise<void> | void {\n    this.update();\n    if (returnPromise === true) {\n      if (this.rendering$.getValue() === false) {\n        return Promise.resolve();\n      } else {\n        return toPromise.call(this.renderState.pipe(\n          filter( state => !state )\n        ));\n      }\n    }\n  }\n\n  getOverride(item: RenderInstruction): DynamicFormOverrideDirective | undefined {\n    return this.overrideMap.get(item);\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (changes.hotBind) {\n      this.hotBind = this.hotBind != null && `${this.hotBind}` !== 'false';\n    }\n\n    if (changes.exclude) {\n      this.onStateChange('exclude', changes.exclude);\n    }\n\n    if (changes.disabledState) {\n      this.onStateChange('disabled', changes.disabledState);\n    }\n\n    if (changes.hiddenState) {\n      this.onStateChange('hidden', changes.hiddenState);\n    }\n  }\n\n  ngDoCheck() {\n    if (this.exclude && this.stateDiffer.exclude) {\n      const diff = this.stateDiffer.exclude.diff(this.exclude);\n      if (diff) {\n        this.handleDiff('exclude', diff);\n      }\n    }\n\n    if (this.disabledState && this.stateDiffer.disabled) {\n      const diff = this.stateDiffer.disabled.diff(this.disabledState);\n      if (diff) {\n        this.handleDiff('disabled', diff);\n      }\n    }\n\n    if (this.hiddenState && this.stateDiffer.hidden) {\n      const diff = this.stateDiffer.hidden.diff(this.hiddenState);\n      if (diff) {\n        this.handleDiff('hidden', diff);\n      }\n    }\n  }\n\n  ngAfterContentInit(): void {\n    const clone = this.tdmModelFormService.createRICloneFactory<LocalRenderInstruction>();\n    this.renderInstructions = this.tdmForm.renderData.map(clone);\n\n    this.afterInit = true;\n    this.updateOverrides();\n\n    const s = this.overrides.changes.subscribe(() => this.updateOverrides());\n    this.subscriptions.push(s);\n  }\n\n  ngAfterViewInit(): void {\n    if (this._ngNativeValidate === true) {\n      this.setNativeValidation();\n    }\n  }\n\n  ngOnDestroy(): void {\n    let subs: Subscription;\n    while (subs = this.subscriptions.pop()) { // tslint:disable-line\n      subs.unsubscribe();\n    }\n    this.arrayActionRequest$.complete();\n    this.rendering$.complete();\n    this.beforeRender.complete();\n    this.valueChanges.complete();\n  }\n\n  /**\n   * Returns the form control for a given key\n   * @param key\n   * @returns\n   */\n  getControl(key: string): AbstractControl | null {\n    return this.tdmForm.get(key);\n  }\n\n  /**\n   * API to manually add field override templates, use this if you want to apply overrides but can not\n   * set the content projection in the template.\n   */\n  addOverride(name: string, tRef: TemplateRef<DynamicFormOverrideContext>, update: boolean = true): void {\n    const d = new DynamicFormOverrideDirective(tRef, this);\n    d.dynamicFormOverride = name;\n    if (name === '*') {\n      this.wildOverride = d;\n      this.wildOverride['__CUSTOM_ADD_OW__'] = true;\n    } else {\n      this.codeOverrides.push(d);\n    }\n\n    if (update) {\n      this.update();\n    }\n  }\n\n  emitArrayActionRequest(renderInstruction: RenderInstruction,\n                         request: Omit<ArrayActionAddRequestEvent, 'tdmForm' | 'fullName' | 'runtimePath'>): void;\n  emitArrayActionRequest(renderInstruction: RenderInstruction,\n                         request: Omit<ArrayActionRemoveRequestEvent, 'tdmForm' | 'fullName' | 'runtimePath'>): void;\n  emitArrayActionRequest(renderInstruction: RenderInstruction,\n                         request: Omit<ArrayActionMoveRequestEvent, 'tdmForm' | 'fullName' | 'runtimePath'>): void;\n  emitArrayActionRequest(renderInstruction: RenderInstruction, request: Partial<ArrayActionRequestEvent>): void {\n    // TODO: validate input.\n    request.tdmForm = this.tdmForm;\n    request.fullName = renderInstruction.fullName;\n    request.runtimePath = renderInstruction.getRuntimePath(request.formArray);\n    this.arrayActionRequest$.emit(<any> request);\n  }\n\n  private updateOverrides(): void {\n    const match = this.overrides.find( ow => ow.dynamicFormOverride === '*' );\n    // we update the wildOverride, but we check if the old wildOverride was added using addOverride method (custom)\n    // if so (no match and old added manually) we will leave it.\n    // we do that because it's most likely we won't find template overrides when custom is set\n    // it also means template wins over custom\n    if (match || !this.wildOverride || this.wildOverride['__CUSTOM_ADD_OW__'] !== true) {\n      this.wildOverride = match;\n    }\n\n    this.update();\n  }\n\n  private update(): void {\n    if (!this.tdmForm || !this.afterInit) {\n      return;\n    }\n\n    if (this.pendingUpdates > 0) {\n      this.pendingUpdates += 1;\n      return;\n    }\n\n    // we wmit the rendering state async\n    const controlsReady: Array<Promise<any>> = [new Promise((resolve) => setTimeout(() => {\n      this.emitRenderingState(true);\n      resolve();\n    }))];\n    const controls: LocalRenderInstruction[] = [];\n    const controlsMap: { [path: string]: RenderInstruction } = this.instructions = {};\n    const controlsPromiseSetter = done => controlsReady.push(done);\n    this.overrideMap.clear();\n\n    const overrides = this.overrides.toArray().concat(this.codeOverrides);\n    const excluded = this.exclude && this.exclude.slice();\n    const hiddenState = this.hiddenState && this.hiddenState.slice();\n    const processInstructions = (rd: LocalRenderInstruction) => {\n      const fullPath: string = rd.fullName;\n      if (!excluded || !this.isStaticPathContainsPath(excluded, fullPath)) {\n        let override = overrides.find(ow => ow.dynamicFormOverride === fullPath) || this.wildOverride;\n        if (override) {\n          this.overrideMap.set(rd, override);\n        }\n\n        // update hidden state of each item\n        if ( hiddenState && this.isStaticPathContainsPath(hiddenState, fullPath) ) {\n          setDisplay(rd, 'none');\n        }\n        controlsMap[fullPath] = rd;\n        controls.push(rd);\n      }\n    };\n\n    this.renderInstructions.forEach(processInstructions);\n\n    const renderEvent = new BeforeRenderEventHandler(controlsMap, controlsPromiseSetter);\n    this.beforeRender.emit(renderEvent);\n\n    this.pendingUpdates += 1;\n    Promise.all(controlsReady)\n      // tslint:disable-next-line\n      .catch( err => {}) // we swallow errors, these should be handled by the user\n      .then( () => {\n        this.pendingUpdates -= 1;\n\n        if (this.pendingUpdates > 0) {\n          this.pendingUpdates = 0;\n          this.update();\n          return;\n        } else {\n          this.instructions = controlsMap;\n          this.controls.next(controls.sort((a, b) => a.ordinal - b.ordinal));\n          this.emitRenderingState(false);\n        }\n      });\n  }\n\n  /**\n   * Check's if an array of paths that might be static or partial are part of the provided full static path.\n   * For example: pathList: ['address'], fullPath: 'address.street' -> true\n   *\n   * TODO: This is called from the update() method and can be improved.\n   * because it use a RenderInstruction it has the full path as an array so we can flag levels so next call to deep\n   * a nested item will fail on the spot cause it's first level was blocked.\n   * e.g. if user blocked 'address' and next item is 'address.name' or 'address.x.y.z' it will fail on the spot because\n   * all of the address object is blocked. Current state is full check for all children of address.\n   */\n  private isStaticPathContainsPath(pathList: string[], fullPath: string): boolean {\n    const idx = pathList.findIndex( p => fullPath.indexOf(p) === 0);\n    if (idx > -1) {\n      const nextChar = fullPath[pathList[idx].length];\n      return !nextChar || nextChar === '.';\n    }\n    return false;\n  }\n\n  private emitRenderingState(state: boolean): void {\n    if (this.rendering$.getValue() === !state) {\n      this.rendering$.next(state);\n    }\n  }\n\n  private applyFormListener(): void {\n    let freeze: boolean;\n    const s = this.tdmForm.form.valueChanges.subscribe(formValue => {\n      const diff = this.valueDiffer.diff(formValue);\n      // we diff before freeze check so we won't pile changes to next step.\n      if (freeze || this.freezeValueChanges) {\n        return;\n      }\n      if (diff) {\n        const arr: TdmFormChanges = [];\n        diff.forEachChangedItem(change => {\n          if (this.hotBind === true) {\n            this.instance[change.key] = change.currentValue;\n          }\n          if (this.isFlattenedProp(change.key)) {\n            arr.push(...this.drillDownChange(change, [change.key]));\n          } else {\n            arr.push(change);\n          }\n        });\n        if (arr.length > 0) {\n          freeze = true;\n          this.valueChanges.next(arr);\n          freeze = false;\n        }\n      }\n    });\n    this.subscriptions.push(s);\n  }\n\n  private isFlattenedProp(key: string, level: number = 0): boolean {\n    return this.tdmForm.renderData.some( r => !!r.flattened && r.flattened[level] === key );\n  }\n\n  /**\n   * Drills down a change in an object of a `flattened` property and returns the changes in the object.\n   * The drill down is recursive so nested flattened properties will reflect the changes as well.\n   *\n   * The `key` of each change will be in the dot notation format.\n   *\n   * ## Why?\n   * The form `valueChanges` stream will emit changes to controls on the first level, if a nested control\n   * (i.e FormGroup or FormArray) has child that changed the stream will not reflect that and will only emit an event\n   * for the top-level control itself.\n   *\n   * This resolution is an issue when using flattened rendering.\n   * While UI shows a flat form the underlying structure is left intact and each flattened property gets a `FormGroup`\n   * attached to it, emitting [[DynamicFormComponent.valueChanges]] events for flattened properties will have low\n   * resolution because the change event will include the top-level key only and the current/previous values will be\n   * the top-level objects themselves and not the actual child value that changed.\n   *\n   * To enhance the resolution this method will drill down the value of a change to find the internal changes in the\n   * object and return them, this is done by diffing the previous value with the current value.\n   * Each drill down is recursive so a flattened object with a nested flattened object will also get proper resolution.\n   *\n   * You must call this function with a change for a property that is known to be defined as flattened and include\n   * it in the `path` parameter as the first (and only) item.\n   *\n   * > Make sure not to confuse flattened nested objects with nested objects that are not defined as flattened by the\n   * user, those will not apply here.\n   * @param change\n   * @param path\n   */\n  private drillDownChange(change: KeyValueChangeRecord<string, any>,\n                          path: Array<string |  number>): Array<KeyValueChangeRecord<string, any>> {\n    const result: Array<KeyValueChangeRecord<string, any>> = [];\n    if (change.previousValue) {\n      const differ = this.kvDiffers.find(change.previousValue).create();\n      differ.diff(change.previousValue);\n      const diff = differ.diff(change.currentValue);\n      if (diff) {\n        diff.forEachChangedItem((c: any) => {\n          if (this.isFlattenedProp(c.key, path.length)) {\n            result.push(...this.drillDownChange( <any> c, path.concat([c.key]) ));\n          } else {\n            c = Object.create(c, { deep: { value: true }, key: { value: path.join('.') + `.${c.key}` } });\n            result.push(c);\n          }\n        });\n      }\n    } else if (change.currentValue) {\n      change = Object.create(change, { deep: { value: true }, key: { value: path.join('.') + `.${change.key}` } });\n      result.push(change);\n    }\n    return result;\n  }\n\n  private setNativeValidation(): void {\n    if (this.formElRef) {\n      if (this._ngNativeValidate === true) {\n        this.renderer.removeAttribute(this.formElRef.nativeElement, 'novalidate');\n      } else {\n        this.renderer.setAttribute(this.formElRef.nativeElement, 'novalidate', '');\n      }\n    }\n  }\n\n  private onStateChange(type: StateKeys, state: SimpleChange): void {\n    let differ: IterableDiffer<string> = this.stateDiffer[type];\n    if (!state.currentValue && differ) {\n      const diff = differ.diff([]);\n      if (diff) {\n        this.handleDiff(type, diff);\n      }\n      differ = undefined;\n    } else if (!state.previousValue && state.currentValue) {\n      differ = this.itDiffers.find(state.currentValue).create();\n    }\n    this.stateDiffer[type] = differ;\n  }\n\n  private handleDiff(type: StateKeys, diff: IterableChanges<string>): void {\n    switch (type) { // tslint:disable-line\n      case 'disabled':\n        this.freezeValueChanges = true;\n        diff.forEachAddedItem( record => this.getControl(record.item).disable());\n        diff.forEachRemovedItem( record => this.getControl(record.item).enable());\n        this.freezeValueChanges = false;\n        break;\n      case 'exclude':\n        this.update();\n        break;\n      case 'hidden':\n        diff.forEachAddedItem( record => {\n          const item = this.findRenderInstructionByKey(record.item);\n          if (item && setDisplay(item, 'none')) {\n            this.update();\n          }\n        });\n        diff.forEachRemovedItem( record => {\n          const item = this.findRenderInstructionByKey(record.item);\n          if (item && setDisplay(item)) {\n            this.update();\n          }\n        });\n        break;\n    }\n  }\n\n  /**\n   * Find's a RenderInstruction using the provided static property path.\n   * Note that a property path might point to a virtual RenderInstruction, such that does not actually render in the UI\n   * but has children that does.\n   */\n  private findRenderInstructionByKey(dotProperty: string): LocalRenderInstruction | undefined {\n    for (let c of this.controls.value) {\n      const fullPath = c.fullName;\n      if (fullPath.indexOf(dotProperty) > -1) {\n        const nextChar = fullPath[dotProperty.length];\n        if (!nextChar) {\n          return c;\n        } else if (nextChar === '.') {\n          let len = fullPath.substr(dotProperty.length + 1).split('.').length;\n          while (len-- > 0) {\n            c = <any> c.parent;\n          }\n          return c;\n        }\n      }\n    }\n  }\n}\n\n/**\n * Set's the state of the display property in the LocalRenderInstruction.\n * Take's into consideration parent's state when computing the child's state.\n * returns `true` when the operation included changes in children\n */\nfunction setDisplay(ri: LocalRenderInstruction, value?: 'none'): boolean {\n  if (ri.display !== value) {\n    ri._dSelf = !!value;\n    ri.display = ri._dSelf || ri._dParent ? 'none' : undefined;\n    return tryRunOnChildren(ri, ri._dSelf);\n  }\n  return false;\n}\n\nfunction setDisplayParent(ri: LocalRenderInstruction, value: boolean): void {\n  ri._dParent = value;\n  ri.display = ri._dSelf || ri._dParent ? 'none' : undefined;\n  tryRunOnChildren(ri, value);\n}\n\nfunction tryRunOnChildren(ri: LocalRenderInstruction, value: boolean): boolean {\n  const children = ri.isVirtual ? ri.virtualChildren : ri.isArray ? ri.children : undefined;\n  if (children) {\n    children.forEach( child => setDisplayParent(<any> child, value) );\n    return true;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/@tdm/ngx-dynamic-forms/src/dynamic-forms/dynamic-form.component.ts","import { ValidatorFn, AsyncValidatorFn } from '@angular/forms';\nimport { MetaClass, PropMetadata, BaseMetadata, DecoratorInfo, TypeMetadataArgs, Constructor, TypeMetadata } from '@tdm/core/tdm';\nimport { RenderDef } from '../../interfaces';\n\nexport interface FormPropMetadataArgs {\n  /**\n   * Exclude this property from the form.\n   * By default every class property decorated with @Prop or @FormProp is included in the output of\n   * a serialization process. Setting Exclude will make sure it is not part of the form.\n   *\n   * > NOTE: Setting exclude via `@Exclude` or `@Prop` with `exclude` does not exclude the `@FormProp`.\n   */\n  exclude?: boolean;\n\n  /**\n   * Transform the value\n   * @param value\n   */\n  transform?: (value: any) => any;\n\n  /**\n   * Definition for element rendering.\n   * Set this if you want your models to automatically render into forms.\n   */\n  render?: RenderDef;\n\n  /**\n   * Sugar for adding a required validator\n   */\n  required?: boolean;\n\n  /**\n   * Flattens the rendering of an object or an array of objects into the root so they are rendered in the root level\n   * with other properties on the instance.\n   *\n   * A flattening definitions is a key -> value map where key's are the properties of the type decorated and the values\n   * are [[FormPropMetadataArgs]] for each property, it's sort of manual form control definition for a type.\n   *\n   * A flatten definition is defined on [[[[FormPropMetadataArgs]]]] and creates internal [[FormPropMetadataArgs]] values so\n   * we can say that it is recursive, i.e. you can define a flatten definition with one or more of the children having\n   * flatten definitions of their own and the same for the children of the children...\n   *\n   * Notice that flattening apply only on the rendering, it does not change the structure of the model and the generated\n   * form structure is identical to the model structure.\n   *\n   * The library will manage the transformation to and from the UI.\n   *\n   * ## Arrays\n   * When a flatten definition decorates an Array of T the array should be ignored and the definition should reflect the\n   * type of T, the fact that the type is and Array of T should not make a difference and the library will take that\n   * into account.\n   *\n   * NOTE: When decorating an Array of T, make sure to include the type, either in `@Prop` metadata or in the\n   * `rtType` property in [[FormPropMetadataArgs]] or it will register as Array<Object>.\n   *\n   * > Must decorate an object or array of objects, primitives are not allowed.\n   * Instructions for flattening the object referenced on this property.\n   * The property must reference a JS object.\n   *\n   * flatten properties does not require a render instructions.\n   * When set, the property is treated as a plain object regardless of it's type so you can also send plain JS objects.\n   *\n   * NOTE: [[FormPropMetadataArgs]] definitions in a flatten instruction might not support all features.\n   *       If you want to maximize use make sure to manually define the run-time types.\n   */\n  flatten?: { [key: string]: FormPropMetadataArgs };\n\n  /**\n   * Declares the property as a nested child form.\n   * The property type must a complex object.\n   * This has no effect on UI rendering, only used by the mapper.\n   */\n  childForm?: boolean;\n\n  // tsline:disable\n  /**\n   * Type definition declaration to be used by the form builder.\n   * Setting type definition overrides any existing type definition, explicit or implicit.\n   *\n   * ## When to use:\n   * `@tdm` identify the type automatically (implicit) but you can also use the `@Prop` decorator and explicitly set the\n   * type using a type getter or the type directly (see [[PropMetadataArgs.type]]).\n   *\n   * When `rtType` is not set the form builder will use the existing type information, this is the recommended approach.\n   *\n   * You would want to use `rtType` when:\n   *   1. The existing type information is not enough AND\n   *   2. The property is not decorated with `@Prop`\n   *\n   * (1) The existing type information is usually enough but in some cases it requires manual definition done in using\n   * the `@Prop` decorator, these are the most common scenarios:\n   *   - Circular module dependency (see https://blog.angularindepth.com/what-is-forwardref-in-angular-and-why-we-need-it-6ecefb417d48)\n   *   - When using `this` or `any` type\n   *   - When using Array of T (e.g. `string[]` or `Array<number>`) (see https://github.com/Microsoft/TypeScript/issues/7169)\n   *\n   * (2)\n   * It is not mandatory to decorate a property with `@Prop` when decorating it with `@FormProp`, i.e. `@FormProp` can\n   * be the only decorator for a property.\n   * An example would be a property in a model/resource that is only required for the form and it is not part of the\n   * resource.\n   *\n   * If both (1) and (2) exist you would need to define a the type information using `rtType`.\n   * If only (1) exists use `@Prop` to define the type information, this will help with consistency.\n   *\n   * It might be that you will need `rtType` in other scenarios, if so remember that it will override all existing type\n   * information for the form builder only.\n   *\n   * ## How to use:\n   * The builder will auto-set missing or unset type information, if exists.\n   * Set [[TypeDefinition.ref]] property to the type, or a type getter function.\n   * Set [[TypeDefinition.forwardRef]] property to true, only then using type getter function in `ref`\n   * Set [[TypeDefinition.isArray]] property when defining a property in a `flatten` definition or when the type\n   * annotation for the property is not an array, otherwise this value is automatically set by the builder\n   *\n   * SEE [[TypeMetadataArgs]] for more information\n   */\n  rtType?: TypeMetadataArgs;\n  // tsline:enable\n\n  /**\n   * The default value\n   */\n  defaultValue?: any;\n\n  validators?: ValidatorFn | ValidatorFn[];\n  asyncValidators?: AsyncValidatorFn | AsyncValidatorFn[];\n}\n\nexport const BASE_RENDERER: RenderDef = {\n  ordinal: Number.MAX_SAFE_INTEGER\n};\n\n@MetaClass<FormPropMetadataArgs, FormPropMetadata>({\n  allowOn: ['member'],\n  extend: 'prop',\n  proxy: {\n    host: PropMetadata,\n    containerKey: 'form'\n  }\n})\nexport class FormPropMetadata extends BaseMetadata {\n  transform: (value: any) => any;\n  exclude: boolean;\n  required: boolean;\n  defaultValue: any;\n  render: RenderDef;\n  validators: ValidatorFn[] | null;\n  asyncValidators: AsyncValidatorFn[] | null;\n  childForm: boolean;\n  flatten?: { [key: string]: FormPropMetadata };\n  rtType?: TypeMetadata;\n\n  constructor(metaArgs: FormPropMetadataArgs, info: DecoratorInfo, target?: Constructor<any>) {\n    super(info);\n    this.render = Object.create(BASE_RENDERER);\n    if (metaArgs) {\n      this.transform = metaArgs.transform;\n      this.exclude = metaArgs.exclude;\n      if (metaArgs.hasOwnProperty('defaultValue')) {\n        this.defaultValue = metaArgs.defaultValue;\n      }\n      this.validators = this.normValidators(metaArgs.validators);\n      this.required = metaArgs.required;\n      this.asyncValidators = this.normValidators(metaArgs.asyncValidators);\n      if (!this.exclude && metaArgs.render) {\n        Object.assign(this.render, metaArgs.render);\n      }\n\n      if (metaArgs.childForm) {\n        // TODO: If childForm, check type and see type is a FormModel as well\n        //       This requires some thinking because at this point the type might be undefined if it's a getter.\n        this.render.type = 'form';\n        this.childForm = true;\n      }\n\n      if (metaArgs.rtType) {\n        this.rtType = new TypeMetadata(metaArgs.rtType, info, target);\n      }\n\n      if (metaArgs.flatten) {\n        this.flatten = {};\n        for (let key of Object.keys(metaArgs.flatten)) {\n          this.flatten[key] = new FormPropMetadata(metaArgs.flatten[key], { type: 'member', name: key });\n        }\n      }\n    }\n  }\n\n  private normValidators(v: any): any[] | null {\n    return !v ? null : Array.isArray(v) ? v : [v];\n  }\n\n  static EMPTY = new FormPropMetadata({} as any, { type: 'class'} );\n}\n\ndeclare module '@tdm/core/tdm/src/metadata/prop' {\n  interface PropMetadataArgs {\n    form?: FormPropMetadataArgs | undefined;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/@tdm/ngx-dynamic-forms/src/core/metadata/form-prop.ts","import { ValidatorFn, AsyncValidatorFn } from '@angular/forms';\nimport { MetaClass, PropMetadata, ModelMetadata, BaseMetadata, DecoratorInfo, stringify, isJsObject } from '@tdm/core/tdm';\n\nimport { FormPropMetadata } from './form-prop';\n\nexport interface FormModelMetadataArgs {\n  validator?: ValidatorFn;\n  asyncValidator?: AsyncValidatorFn;\n}\n\n@MetaClass<FormModelMetadataArgs, FormModelMetadata>({\n  single: true,\n  allowOn: ['class'],\n  proxy: {\n    host: ModelMetadata,\n    containerKey: 'form'\n  }\n})\nexport class FormModelMetadata extends BaseMetadata implements FormModelMetadataArgs {\n  validator: ValidatorFn | null;\n  asyncValidator: AsyncValidatorFn | null;\n  props = new Map<string, FormPropMetadata>();\n\n  constructor(metaArgs: FormModelMetadataArgs | undefined, info: DecoratorInfo) {\n    super(info);\n\n    if (isJsObject(metaArgs)) {\n      this.validator = metaArgs.validator || null;\n      this.asyncValidator = metaArgs.asyncValidator || null;\n    }\n  }\n\n  addProp(prop: PropMetadata, metaArgs: FormPropMetadata, target: any) {\n    if (!metaArgs.exclude && !metaArgs.render.type) {\n      const type = metaArgs.rtType || prop.type;\n      switch (type.ref) {\n        case Boolean:\n          metaArgs.render.type = 'boolean';\n          break;\n        case String:\n          metaArgs.render.type = 'text';\n          break;\n        case Number:\n          metaArgs.render.type = 'number';\n          break;\n        default:\n          if (!metaArgs.flatten) {\n            throw new Error(`Invalid property type or type not set in ${stringify(target)}.${prop.name}`);\n          }\n      }\n    }\n    this.props.set(prop.name as any, metaArgs);\n  }\n\n  getProp(propertyKey: string): FormPropMetadata | undefined {\n    return this.props.get(propertyKey);\n  }\n}\n\ndeclare module '@tdm/core/tdm/src/metadata/model-metadata' {\n  interface ModelMetadataArgs {\n    form?: FormModelMetadataArgs | undefined | true;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/@tdm/ngx-dynamic-forms/src/core/metadata/form-model.ts","import {\n  FormGroup,\n  FormControl,\n  AbstractControl,\n  Validators,\n  FormArray,\n  ValidatorFn,\n  AsyncValidatorFn\n} from '@angular/forms';\nimport {\n  targetStore,\n  isUndefined,\n  isFunction,\n  isPrimitive,\n  stringify,\n  directMapper,\n  Constructor,\n  TypeMetadata,\n  PropMetadata,\n  PropertyContainer,\n  MapperFactory,\n  PoClassPropertyMap,\n  SerializeMapper,\n  DeserializeMapper,\n  DirectDeserializeMapper,\n  PlainObjectMapper\n} from '@tdm/core/tdm';\n\nimport { FormModelMetadata, FormPropMetadata } from './metadata/index';\nimport { objectToForm } from '../utils';\n\nexport type DeserializableForm = FormGroup | FormArray;\n\nexport class NgFormsDeserializeMapper extends DirectDeserializeMapper {\n  readonly raw: boolean = true;\n  protected formModel: FormModelMetadata | undefined;\n\n  constructor(public formGroup: DeserializableForm, sourceType: any, plainMapper?: PlainObjectMapper) {\n    super(formGroup.value, sourceType, plainMapper);\n    this.formModel = targetStore.getMetaFor(sourceType, FormModelMetadata, true);\n  }\n\n  getIdentity(): string {\n    // TODO: Move to the global store, so logic can change without bugs.\n    if (this.identity) {\n      return this.formGroup.get(this.identity).value;\n    }\n  }\n\n  getKeys(): string[] {\n    // we don't care about excluded `FormPropMetadata` because they will not get here since the serializer\n    // will not include them, it should be a closed loop.\n    const controls = this.formGroup.controls;\n    if (this.formGroup instanceof FormArray) {\n      return [];\n    } else {\n      return Object.keys(controls).filter( k => controls[k].dirty);\n    }\n  }\n\n  getValue(key: string, prop?: PropMetadata): any {\n    const control = this.formGroup.get(key);\n    if (control instanceof FormArray) {\n      const formProp = (this.formModel && this.formModel.getProp(key as string)) || FormPropMetadata.EMPTY;\n      // TODO: we can omit this, maybe protect against but rtType should ne set at this point.\n      if (!formProp.rtType && prop && prop.type) {\n        formProp.rtType = prop.type;\n      }\n      return this.parseFormArray(control, key, formProp);\n    } else if (control instanceof FormGroup) {\n      /* NOTE:\n         Normally we would check for shared instances (relations) in the cache to prevent circular reference between 2\n         models that reference each other, however, a form value (root object) can not share the same instance\n         on 2 nodes within it's graph as it will cause infinite rendering of controls as forms are not built for this.\n\n         If, for any reason, this is required in the future, this code should ne added:\n\n         if (prop) {\n           const rel = this.getRelationQuery(prop, value);\n           if (rel) { value = rel; }\n         }\n\n         And:\n         this.getCache(type.ref, value) || this.deserialize(<any> control, prop);\n      */\n\n      const formProp = (this.formModel && this.formModel.getProp(key as string)) || FormPropMetadata.EMPTY;\n      // TODO: we can omit this, maybe protect against but rtType should ne set at this point.\n      if (!formProp.rtType && prop && prop.type) {\n        formProp.rtType = prop.type;\n      }\n      return this.parseFormGroup(control, key, formProp);\n    } else {\n      return control.value;\n    }\n  }\n\n  protected parseFormArray(control: FormArray, key: string, formProp: FormPropMetadata): any {\n    if (formProp.flatten) {\n      return this.deserializeFlattened(control, formProp, key);\n    } else {\n      const value = [];\n      for (let c of control.controls) {\n        if (c instanceof FormArray) {\n          value.push(this.parseFormArray(c, key, formProp));\n        } else if (c instanceof FormGroup) {\n          value.push(this.parseFormGroup(c, key, formProp));\n        } else {\n          value.push(c.value);\n        }\n      }\n      return value;\n    }\n  }\n\n  protected parseFormGroup(c: FormGroup, key: string, formProp: FormPropMetadata): any {\n    const type = formProp.rtType;\n    if (formProp.flatten) {\n      return this.deserializeFlattened(c, formProp, key);\n    } else if (type && targetStore.hasTarget(type.ref)) {\n      return this.deserialize(c, type);\n    } else {\n      return this.plainMapper.deserialize(c.getRawValue());\n    }\n  }\n\n  protected deserialize(value: DeserializableForm, prop: TypeMetadata): any;\n  protected deserialize(value: DeserializableForm, prop: PropMetadata): any;\n  protected deserialize(value: DeserializableForm, prop: PropMetadata | TypeMetadata): any {\n    const type: TypeMetadata = prop instanceof TypeMetadata ? prop : prop.type;\n    const mapper = this.ref\n      ? new NgFormsDeserializeMapper(value, type.ref)\n      : directMapper.deserializer(value, type.ref)\n    ;\n    return targetStore.deserialize(mapper);\n  }\n\n  /**\n   * Deserialize a control with ad-hoc \"flatten\" instruction of property to form control mappings.\n   * Flattening can only be done on complex objects so `control` must be a FormArray or FormGroup.\n   *\n   * `resultOrKey` is used to provide an existing value to merge the deserialized data into.\n   * You can also provide a string/number that used as a key to retrieve the value from an existing instance.\n   *\n   * When `resultOrKey` resolves to a NON-PRIMITIVE TRUTHY value (i.e. object/array) the deserializer will merge the\n   * value of the DIRTY controls into the object at `resultOrKey`. This means that when a `resultOrKey` is supplied only\n   * the dirty controls are evaluated and merged, a lazy approach.\n   *\n   * When `resultOrKey` resolves to a primitive value (i.e. not an object/array) or a falsy value (e.g. null/undefined)\n   * a new object is created and the deserializer will merge all of the controls, DIRTY and NOT DIRTY, into the newly\n   * created object.\n   *\n   * This base implementation of `deserializeFlattened` does not support key (string/number) retrieval as there is no\n   * model instance attached to the deserializer and so it will treat them as falsy values.\n   * Derived classes might use this option and override `deserializeFlattened` so they can re-call it after retreiving\n   * the actual value using the key.\n   *\n   * @param control The form control to deserialize, only FormArray or FormGroup\n   * @param formProp The FormPropertyMetadata instance for the property.\n   * @param resultOrKey\n   */\n  protected deserializeFlattened(control: DeserializableForm,\n                                 formProp: FormPropMetadata,\n                                 resultOrKey?: string | number | any): any {\n    if (control instanceof FormArray) {\n      const { controls } = control;\n      const result = [];\n      for (let i = 0, len = controls.length; i < len; i++) {\n        const c = controls[i];\n        if (c instanceof FormArray || c instanceof FormGroup) {\n          // we send null when c might be array, but when c is FormArray the result is force set to []\n          // null is also used to force serialization of all controls, not only the dirty one's.\n          result.push(this.deserializeFlattened(c, formProp, null));\n        } else {\n          result.push(c.value);\n        }\n      }\n      return result;\n    } else {\n      const forceSerialize = isPrimitive(resultOrKey) || !resultOrKey;\n      // this method does not support string/number in `resultOrKey`\n      const result: any = forceSerialize ? {} : resultOrKey;\n\n      const props = formProp.flatten;\n      const keys = Object.keys(props);\n      for (let key of keys) {\n        const childCtrl = control.get(key);\n        const p = props[key];\n        let value: any = keys; // keys is unique so it can never be set from the outside.\n        if (p.flatten) {\n          if (forceSerialize || childCtrl.dirty) {\n            value = this.deserializeFlattened(<any> childCtrl, p, result[key]);\n          }\n        } else if (forceSerialize || childCtrl.dirty) {\n          value = true;\n        } else if (p.hasOwnProperty('defaultValue') && p.defaultValue === control.get(key).value) {\n          value = true;\n        }\n        switch (value) {\n          case keys:\n            break;\n          case true:\n            result[key] = control.get(key).value;\n            break;\n          default:\n            if (result[key]) {\n              Object.assign(result[key], value);\n            } else {\n              result[key] = value;\n            }\n            break;\n        }\n      }\n      return result;\n    }\n  }\n}\n\n// tslint:disable-next-line\nexport class NgFormsSerializeMapper extends SerializeMapper {\n  protected cache: Map<any, any>;\n  protected formModel: FormModelMetadata | undefined;\n\n  serialize(container: PropertyContainer): any {\n    this.formModel = targetStore.getMetaFor(container.target, FormModelMetadata, true);\n    if (!this.formModel) {\n      throw new Error(`Target '${stringify(container.target)}' is not a registered FormModel`);\n    }\n\n    if (!this.cache) {\n      this.cache = new Map<any, any>();\n    }\n\n    if (Array.isArray(this.source)) {\n      return this.serializeCollection(this.source, container);\n    } else {\n      return this.serializeObject(this.source, container);\n    }\n  }\n\n  protected serializeObject(obj: any, container: PropertyContainer): FormGroup {\n    const data: FormGroup = new FormGroup({}, this.formModel.validator, this.formModel.asyncValidator);\n\n    const cb = (prop: PoClassPropertyMap) => {\n      const meta = prop.prop;\n\n      if (!meta) {\n        return;\n      }\n      const formProp = this.formModel.getProp(meta.name as string) || FormPropMetadata.EMPTY;\n      if (!formProp.rtType) {\n        formProp.rtType = meta.type;\n      }\n      const ctrl = this.createControl(formProp, obj ? obj[prop.cls] : undefined);\n      if (ctrl) {\n        data.addControl(prop.obj, ctrl);\n      }\n    };\n\n    // don't care if @Excluded was set, if @Prop there we check it\n    container.forEachRaw(obj ? Object.keys(obj) : [], cb);\n\n    const idKey = targetStore.getIdentityKey(container.target);\n    if (data.get(idKey) && idKey !== targetStore.getIdentityKey(container.target, 'outgoing')) {\n      data.removeControl(idKey);\n    }\n\n    return data;\n  }\n\n  /**\n   * Create a form control from a [[FormPropMetadata]] instance.\n   * @param formProp\n   * @param value\n   * @param ignoreArray If true, treats the type as non-array, even if the type information says it is an\n   * array. `ignoreArray` is ignored if `value` is an array instance by itself.\n   * `ignoreArray` is used when the same [[FormPropMetadata]] decorating a property of type Array<T> is used\n   * recursively, first time for the array value and then n times (array length) for the items in the array. The actual\n   * type for each item is that [[FormPropMetadata]].\n   */\n  protected createControl(formProp: FormPropMetadata, value: any, ignoreArray?: boolean): AbstractControl | undefined {\n    if (formProp.exclude) {\n      return;\n    }\n\n    if (isFunction(formProp.transform)) {\n      value = formProp.transform(value);\n    }\n\n    if (isUndefined(value)) {\n      value = formProp.defaultValue;\n    }\n\n    const { rtType } = formProp;\n    const isArray = Array.isArray(value) || ( ignoreArray ? false : rtType && rtType.isArray );\n    let ctrl: AbstractControl;\n\n    if (formProp.childForm === true && rtType && rtType.ref) {\n      const hasTarget = targetStore.hasTarget(rtType.ref);\n      if (isArray) {\n        ctrl = new FormArray([]);\n        if (Array.isArray(value)) {\n          for (let item of value) {\n            (ctrl as FormArray).push(hasTarget ? this.serializeChild(rtType, item) : objectToForm(item));\n          }\n        }\n      } else {\n        ctrl = hasTarget ? this.serializeChild(rtType, value) : objectToForm(value);\n      }\n    } else if (formProp.flatten) {\n      value = value ? this.plainMapper.serialize(value) : (isArray ? [] : {});\n      if (isArray) {\n        ctrl = new FormArray([]);\n        for (let item of value) {\n          (ctrl as FormArray).push(this.createControl(formProp, item, true));\n        }\n      } else {\n        ctrl = this.createFlatten(formProp.flatten, value);\n      }\n    } else {\n      if (isArray) {\n        ctrl = new FormArray([]);\n        if (Array.isArray(value)) {\n          for (let item of value) {\n            (ctrl as FormArray).push(new FormControl(item));\n          }\n        }\n      } else {\n        ctrl = new FormControl(value);\n      }\n    }\n\n    const validators = this.getValidators(formProp);\n    if (validators[0]) {\n      ctrl.setValidators(validators[0]);\n    }\n    if (validators[1]) {\n      ctrl.setAsyncValidators(validators[1]);\n    }\n\n    return ctrl;\n  }\n\n  protected createFlatten(flatten: { [key: string]: FormPropMetadata }, value: any): FormGroup {\n    const ctrl = new FormGroup({});\n    const keys = Object.keys(flatten);\n    for (let key of keys) {\n      const flattenedControl = this.createControl(flatten[key], value[key]);\n      if (flattenedControl) {\n        (ctrl as FormGroup).addControl(key, flattenedControl);\n      }\n    }\n    return ctrl;\n  }\n\n  protected getValidators(formProp: FormPropMetadata): [ValidatorFn | null, AsyncValidatorFn | null] {\n    const sync: ValidatorFn[] = formProp.validators\n      ? formProp.validators.slice()\n      : []\n    ;\n\n    if (formProp.required === true) {\n      sync.push(Validators.required);\n    }\n\n    const async = formProp.asyncValidators &&  formProp.asyncValidators.length > 0\n      ? Validators.composeAsync(formProp.asyncValidators)\n      : null\n    ;\n\n    return [sync.length > 0 ? Validators.compose(sync) : null, async];\n  }\n\n  protected serializeChild(type: TypeMetadata, obj: any): FormGroup | FormArray {\n    return targetStore.serialize(type.ref as any, new NgFormsChildSerializeMapper(obj, this.cache, this.plainMapper));\n  }\n\n  protected serializeCollection(arr: any[], container: PropertyContainer): FormArray {\n    return new FormArray(arr.map(s => this.serializeObject(s, container)));\n  }\n\n  /**\n   * Creates a form control based on metadata of a given property in a given model.\n   * If a value is provided the form control will be populated with the value.\n   *\n   * You can provide a string (`prop`) representing the property name, OR if you want to create a control for a property\n   * in a nested object (Only for `@FormProp` declarations with `flatten` expressions OR `childForm` set to true) you\n   * you can provide a tuple a tuple with 2 values the first value is a string representing the\n   * property name at the root level (exposed property that `@FormProp` decorates), the second value is a dot notation\n   * path to the nested property within the flatten expression / Child model.\n   *\n   * For example, in the following flatten expression:\n   *\n   * ```ts\n   * @FormProp({\n   *   flatten: Object.assign({}, basicFlatten, {\n   *     additional: {\n   *       flatten: {\n   *         work: { }\n   *       }\n   *     }\n   *   })\n   * })\n   * myProp: any;\n   * ```\n   * If we want to get the control for `work` the path will be: ` ['myProp', 'additional.work'] `\n   *\n   * > When using a deep path and providing a `value`, the value should be the value to be assign at the resolved path\n   * and not the root value, i.e. the value is not evaluated with each step in the path.\n   *\n   * Make sure not to include array index references within a deep path expression, think of type structure as one\n   * without arrays.\n   *\n   * NOTE: Array's are NOT SUPPORTED by design.\n   * This function DOES NOT support arrays, if a given property is an Array<T> the returned form will be T.\n   * Make sure not to send an array instance with `value`.\n   *\n   * Why?\n   * The purpose of this function is to create form controls to be added to FormArrays.\n   * These can be empty controls or populated with a given `value`.\n   * To support all features (e.g. \"flatten\") and allow empty form controls array are not supported because a property\n   * with type Array<T> and no values in the array will return an empty FormArray.\n   *\n   * If you want to create a FormArray control simple call createControl for each item in the array and add it to the\n   * FormArray:\n   *\n   * ```ts\n   * new FormArray(items.map( item => createControl(MyType, 'myProp', item) ));\n   * ```\n   */\n  static createControl<T, Z>(type: Z & Constructor<T>,\n                             prop: keyof T | [keyof T, string],\n                             value?: any): FormGroup | FormControl | FormControl {\n    if (Array.isArray(value)) {\n      throw new Error('provided value is an array instance which is not allowed.');\n    }\n    const path: string[] = Array.isArray(prop) ? [prop[0], ...prop[1].split('.')].filter( s => !!s ) : [prop];\n\n    const formModel = targetStore.getMetaFor(type, FormModelMetadata, true);\n    if (!formModel) {\n      throw new Error(`Target '${stringify(type)}' is not a registered FormModel`);\n    }\n\n    const key = path.shift();\n    let formProp = formModel.getProp(key);\n    if (!formProp) {\n      throw new Error(`Target '${stringify(type)}' does not have a PropForm decorator for property ${key}`);\n    }\n    let typeMeta = formProp.rtType;\n    if (!typeMeta) {\n      const propMeta = targetStore.getMetaFor(type, PropMetadata, key);\n      formProp.rtType = typeMeta = propMeta.type;\n    }\n\n    /*  At this point there are several scenarios:\n          1. `prop` is a non-deep property path (e.g. \"myProp\")\n             This is the simple scenario, we just create the control for the type & form metadata resolved from\n             the property. If the [[FormMetadata]] instance is a childForm or a flatten expression it will be handled\n             by the serializer.\n\n          2. `prop` is a deep, property path (e.g. \"myProp.nest.value.somewhere\")\n              This is a bit more complex and depends on the [[FormMetadata]] configuration.\n\n                - When [[FormMetadata.childForm]] is `true`:\n\n                  We need to extract the type and call [[NgFormsSerializeMapper#createControl]] again (static method)\n                  with the new type and a new path, the new path is a left-shift of the current path.\n                  Example: Given the mode/resource `MyModel`, when resolving path \"myProp.nest.value.somewhere\"\n                           where \"myProp\" is a known model/resource `MyOtherModel` we first call:\n                              - `NgFormsSerializeMapper.createControl(MyModel, ['myProp', 'vnest.value.somewhere']);`\n                           inside [[NgFormsSerializeMapper.createControl]] we detect `myProp` has `childForm: true` and\n                           that it's type is a known model/resource `MyOtherModel` so we recursively call:\n                           `NgFormsSerializeMapper.createControl(MyOtherModel, ['nest', 'value.somewhere'], value);`\n\n                - When [[FormMetadata.flatten]] is set:\n\n                  We resolve the deep path to get the [[FormMetadata]] it points to (if path is invalid we throw).\n                  Once we get the [[FormMetadata]] instance we use it to get the control.\n\n     */\n    if (path.length > 0) {\n      if (formProp.childForm) {\n        if (!targetStore.hasTarget(typeMeta.ref)) {\n          // tslint:disable-next-line\n          throw new Error(`Error trying deep access with a \"childForm\" found in path section \"${key}\", \"${typeMeta.ref}\" is not a registered model`);\n        }\n        return NgFormsSerializeMapper.createControl(typeMeta.ref, [path.shift(), path.join('.')], value);\n      } else if (formProp.flatten) {\n        while (formProp.flatten && path.length > 0) {\n          formProp = formProp.flatten[path.shift()];\n        }\n        if (path.length > 0) {\n          throw new Error(`Error trying deep access to a flatten expression ${(prop as string[]).join('.')}`);\n        }\n      }\n    }\n\n    return <any> new NgFormsSerializeMapper(undefined).createControl(formProp, value, true);\n  }\n}\n\n// tslint:disable-next-line\nexport class NgFormsChildSerializeMapper extends NgFormsSerializeMapper {\n  constructor(source: any, protected cache: any /*Map<string, Map<any, any>> */, plainMapper: PlainObjectMapper) {\n    super(source, plainMapper);\n  }\n}\n\nexport const ngFormsMapper: MapperFactory = {\n  serializer(source: any, plainMapper?: PlainObjectMapper): NgFormsSerializeMapper {\n    return new NgFormsSerializeMapper(source, plainMapper);\n  },\n  deserializer(source: DeserializableForm, sourceType: any, plainMapper?: PlainObjectMapper): DeserializeMapper {\n    return new NgFormsDeserializeMapper(source, sourceType, plainMapper);\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/@tdm/ngx-dynamic-forms/src/core/angular-forms-mapper.ts","import { FormGroup } from '@angular/forms';\nimport {\n  targetStore,\n  isString,\n  isNumber,\n  Constructor,\n  PlainObjectMapper,\n  TargetMetadata\n} from '@tdm/core/tdm';\n\nimport { DeserializableForm, NgFormsSerializeMapper, NgFormsDeserializeMapper } from './angular-forms-mapper';\nimport { FormPropMetadata } from './metadata/index';\n\n/**\n * A FormGroup/FormArray deserializer bound to a specific instance.\n *\n */\nclass NgFormsBoundDeserializeMapper extends NgFormsDeserializeMapper {\n\n  constructor(public formGroup: DeserializableForm,\n              sourceType: any,\n              public instance: any,\n              plainMapper?: PlainObjectMapper) {\n    super(formGroup.value, sourceType, plainMapper);\n  }\n\n  /**\n   * Overrides the base class method to set the result from the instance when `resultOrKey` is a string or a number.\n   * Note that it will set the result from the root object, which means that only 1st level properties can be used and\n   * deep references to nested object are not supported.\n   * This should have no effect since the base implementation of `deserializeFlattened`, when calling itself, provides\n   * the `resultOrKey`\n   */\n  protected deserializeFlattened(control: DeserializableForm,\n                                 formProp: FormPropMetadata,\n                                 resultOrKey?: string | number | any): any {\n    if (isString(resultOrKey) || isNumber(resultOrKey)) {\n      resultOrKey = this.instance[resultOrKey];\n    }\n    return super.deserializeFlattened(control, formProp, resultOrKey);\n  }\n}\n\n/**\n * An instance of NgFormsSerializeMapper and NgFormsDeserializeMapper bound to the same type & instance.\n * This is a helper class for easy form management where one can use the same object to serialize\n * and deserialize the model while keeping a reference to the model data.\n */\n// tslint:disable-next-line\nexport class NgFormsBoundMapper<T> {\n  private fg: FormGroup;\n  private meta: TargetMetadata;\n\n  constructor(private readonly type: Constructor<any>, public readonly instance: T) {\n    this.meta = targetStore.getTargetMeta(type);\n  }\n\n  serialize(): FormGroup {\n    return this.fg = this.meta.serialize(new NgFormsSerializeMapper(this.instance));\n  }\n\n  deserialize(): T {\n    this.meta.deserialize(new NgFormsBoundDeserializeMapper(this.fg, this.type, this.instance), this.instance);\n    return this.instance;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/@tdm/ngx-dynamic-forms/src/core/ng-forms-bound-mapper.ts","import { AbstractControl, FormArray } from '@angular/forms';\nimport { FormElementType, RenderDef } from '../interfaces';\n\n/**\n * Render definition with the name of the control.\n *\n * The internal logic for handling render instruction is array based (due to ordering) but the\n * user-defined `RenderDef` is object based (hash) and does not require name (name inferred from key).\n *\n * When moving user-defined render definition into an array we need to preserve the name, this interface\n * defines the contract.\n *\n * @internal\n */\nexport class RenderInstruction<T = any> implements RenderDef<T> {\n\n  /**\n   * A object used to mark changes in the instruction for ngFor iterations.\n   *\n   * @internal\n   */\n  hash: any;\n\n  required?: boolean;\n\n  /**\n   * The order of the control in the form\n   */\n  ordinal?: number;\n\n  /**\n   * The label to display (e.g. placeholder, description etc...)\n   */\n  label?: string;\n\n  /**\n   * The type of the element.\n   *\n   * The rendering component will use this type to render the component.\n   *\n   * If no type is set the library will try to assign a primitive (string, number or boolean) based\n   * on the type information. If no primitive was matched an error is thrown.\n   */\n  type?: keyof FormElementType;\n\n  /**\n   * Extra data to be used by the renderer.\n   *\n   * Examples:\n   *   - regex, min/max, etc.. for validation\n   *   - options (options) array for a select type\n   */\n  data?: T;\n\n  /**\n   * When set indicated this is form control flattened from a nested object.\n   * The string represents the path **from the root control** (NgForm) to the parent of this flattened control.\n   *\n   * The path support the same values accepted by the `get` method in `AbstractControl`, i.e.\n   * you can use dot notation / Array<string | number> to describe deep paths.\n   * See https://angular.io/api/forms/AbstractControl#get\n   */\n  flattened?: Array<string | number>;\n\n  /**\n   * When true the type of the value is a primitive, i.e. the form control is FormControl.\n   * else, the type of the value is complex, i.e. FormGroup.\n   *\n   * If the current instruction is an array (has children) this represents the type of the children.\n   */\n  isPrimitive: boolean;\n\n  /**\n   * A virtual instruction is an instruction that is not part of the rendering flow but represents a physical control.\n   * A virtual instruction is used for form graph control hierarchy, it is the parent of all properties of a flatten\n   * expression.\n   * When flattening, the UI is required to show a nested object or parts of it at the same level of the root, this has\n   * not depth limitation as you can nest flatten declaration. The form is bound to the model and it can not change it's\n   * structure so the library manages the transformation between UI and Data model.\n   *\n   * This is why a virtual field will not be part of the rendering array but will be the parent of a falttened property.\n   */\n  isVirtual: boolean;\n\n  /**\n   * Valid on when isVirtual is true.\n   * Contains the child properties of a complex object, this will usually match the corresponding FormGroup instance\n   * `controls` property where this array is reduces to a key->value object where the keys are the name property of each\n   * instance in the array.\n   */\n  virtualChildren?: RenderInstruction[];\n\n  /**\n   * When true indicates that the instruction is for a FormArray.\n   */\n  isArray: boolean;\n\n  /**\n   * When set indicates that the instruction is for a FormArray.\n   */\n  children?: RenderInstruction[];\n\n  /**\n   * The full name.\n   * The full name is usually identical to the name, except for instructions that are part of a `flattening` expression.\n   *\n   * When the instruction is part of a `flattening` expressions the full name is also refered to as the `static path`\n   * The static path is used for metadata lookup, where all arrays are meaningless and only their type is required.\n   *\n   * > It is recommended to use the full name at all times, except for visual display purpose.\n   */\n  get fullName(): string {\n    const fullName =  this.flattened\n      ? this.flattened.join('.') + '.' + this.name\n      : this.name\n    ;\n    Object.defineProperty(this, 'fullName', { value: fullName, writable: false });\n    return fullName;\n  }\n\n  constructor(renderDef: RenderDef, public name: string, public parent?: RenderInstruction) {\n    Object.assign(this, renderDef);\n    this.hash = this;\n  }\n\n  /**\n   * Call this function when changing properties in this [[RenderInstruction]] instance, before calling\n   * [[DynamicFormComponent.redraw]].\n   */\n  markAsChanged(): void {\n    this.hash = {};\n  }\n\n  /**\n   * A helper method that merge's (assign) the provided value into the existing `data` object.\n   * If a `data` object is undefined it will create one.\n   * @param value\n   */\n  mergeData(value: any): void {\n    this.data = Object.assign(this.data || {}, value);\n  }\n\n  /**\n   * Returns the run-time path for this rendering item, relative to the root control.\n   * The run-time path is the path for form lookup which can be used in [[AbstractControl.get]].\n   *\n   * Because an @angular form control does not know it's name but does know it's parent we can use the rendering\n   * instructions to get the name and move up to the parent up to root to get the full path.\n   * If we find a parent that is an array we lookup the index and use it instead of the name.\n   */\n  getRuntimePath(control: AbstractControl): string {\n    const { parent } = control;\n    if (!parent || parent === control.root) {\n      return this.name;\n    } else {\n      const name = parent instanceof FormArray ? parent.controls.indexOf(control) : this.name;\n      return `${this.parent.getRuntimePath(parent)}.${name}`;\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/@tdm/ngx-dynamic-forms/src/tdm-model-form/render-instruction.ts","import { NgFormsSerializeMapper } from './core/angular-forms-mapper';\n\n/**\n * Run-time path and Static path are different in how they express arrays.\n * A run-time path will express an array index because it refers to instances.\n * A static path will not express an array index because it refer to types, complex or primitive but an array in the\n * static world is only a container of types (Array of T) and does not play a role in static type lookup.\n *\n * ## Example\n * A User class with an info property, info is an object with a name property (string) and an addresses property\n * which is array of address objects. address objects have a street property (string).\n *\n * Run-time path expressions:\n *  1. info.name\n *  2. info.addresses\n *  3. info.addresses.0.street\n *\n * Static path expressions:\n *  1. info.name\n *  2. info.addresses\n *  3. info.addresses.street\n *\n * Only 3 is different since it's an array.\n *\n * Run-time path expressions is used with runtime instance of form controls, static path expressions are used when\n * working with @tdm metadata and it's form serializers and deserializers.\n */\n\n/**\n * Creates a form control based on metadata of a given property in a given model.\n * If a value is provided the form control will be populated with the value.\n *\n * You can provide a string (`prop`) representing the property name, OR if you want to create a control for a property\n * in a nested object (Only for `@FormProp` declarations with `flatten` expressions OR `childForm` set to true) you\n * you can provide a tuple a tuple with 2 values the first value is a string representing the\n * property name at the root level (exposed property that `@FormProp` decorates), the second value is a dot notation\n * path to the nested property within the flatten expression / Child model.\n *\n * For example, in the following flatten expression:\n *\n * ```ts\n * @FormProp({\n *   flatten: Object.assign({}, basicFlatten, {\n *     additional: {\n *       flatten: {\n *         work: { }\n *       }\n *     }\n *   })\n * })\n * myProp: any;\n * ```\n * If we want to get the control for `work` the path will be: ` ['myProp', 'additional.work'] `\n *\n * > When using a deep path and providing a `value`, the value should be the value to be assign at the resolved path\n * and not the root value, i.e. the value is not evaluated with each step in the path.\n *\n * NOTE: Array's are NOT SUPPORTED by design.\n * This function DOES NOT support arrays, if a given property is an Array<T> the returned form will be T.\n * Make sure not to send an array instance with `value`.\n *\n * Why?\n * The purpose of this function is to create form controls to be added to FormArrays.\n * These can be empty controls or populated with a given `value`.\n * To support all features (e.g. \"flatten\") and allow empty form controls array are not supported because a property\n * with type Array<T> and no values in the array will return an empty FormArray.\n *\n * If you want to create a FormArray control simple call createControl for each item in the array and add it to the\n * FormArray:\n *\n * ```ts\n * new FormArray(items.map( item => createControl(MyType, 'myProp', item) ));\n * ```\n */\nexport const createControl = NgFormsSerializeMapper.createControl;\nexport type createControl = typeof NgFormsSerializeMapper.createControl;\n\n\n\n// WEBPACK FOOTER //\n// ./src/@tdm/ngx-dynamic-forms/src/create-control.ts","import { Type, Input, Directive } from '@angular/core';\n\nimport { TDMModelFormService } from './tdm-model-form.service';\nimport { TDMModelForm } from './tdm-model-form';\n\n/**\n * A helper Directive to expose TDMModelForm within a template.\n *\n * This is an alternate method for create forms on a template. Instead of using an injected\n * TDMModelFormService instance to create instances of TDMModelForm you can use this directive.\n *\n * @example\n * ```ts\n * <div #tdmForm=\"tdmModelForm\" [tdmModelForm]=\"user\">\n *   <form [formGroup]=\"tdmForm.form\" novalidate>\n *     <div *ngFor=\"let item of tdmForm.renderData; trackBy: tdmForm.trackBy\" class=\"row\">\n *       <div [ngSwitch]=\"item.type\" class=\"row\">\n *         <input *ngSwitchCase=\"'boolean'\" type='checkbox' [formControlName]=\"item.name\">{{ item.label }} />\n *         <input *ngSwitchCase=\"'text'\" type='text' [formControlName]=\"item.name\">{{ item.label }} />\n *         <input *ngSwitchCase=\"'number'\" type='number' [formControlName]=\"item.name\">{{ item.label }} />\n *      </div>\n *   </form>\n * </div>\n * ```\n */\n@Directive({\n  selector: '[tdmModelForm]',\n  exportAs: 'tdmModelForm'\n})\nexport class TDMModelFormDirective<T> extends TDMModelForm<T> {\n\n  @Input() set tdmModelForm(value: T | [T, Type<T>]) {\n    const [instance, type] = Array.isArray(value) ? value : [value, <any> value.constructor];\n    this.setContext(instance, type);\n  }\n\n  constructor(modelFormService: TDMModelFormService) {\n    super(modelFormService);\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/@tdm/ngx-dynamic-forms/src/tdm-model-form/tdm-model-form.directive.ts","/** PURE_IMPORTS_START .._Observable PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\n// HACK: this is here for backward compatability\n// TODO(benlesh): remove this in v6.\nexport var toPromise = Observable.prototype.toPromise;\n//# sourceMappingURL=toPromise.js.map \n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/_esm5/operator/toPromise.js\n// module id = null\n// module chunks = ","import { Directive, Input, Inject, forwardRef, TemplateRef } from '@angular/core';\nimport { FormGroup } from '@angular/forms';\n\nimport { RenderInstruction } from '../tdm-model-form/render-instruction';\nimport { DynamicFormControlRenderer } from '../tdm-model-form/tdm-model-form';\nimport { DynamicFormComponent } from './dynamic-form.component';\n\nexport interface DynamicFormOverrideContext {\n  $implicit: DynamicFormControlRenderer;\n}\n\n/**\n * A directive that allows override the default renderer for a form control name.\n *\n * @example\n *\n * ```html\n * <dynamic-form #df [model]=\"data.user\" [exclude]=\"['remotePassword']\">\n *   <md-input-container *dynamicFormOverride=\"'localUser'; let ctx\" [formGroup]=\"ctx.fGroup\" >\n *     <input type=\"password\" [formControl]=\"ctx.fControl\" mdInput [placeholder]=\"ctx.item.label\">\n *   </md-input-container>\n * </dynamic-form>\n * ```\n *\n */\n@Directive({\n  selector: '[dynamicFormOverride]',\n  exportAs: 'dynamicFormOverride'\n})\nexport class DynamicFormOverrideDirective {\n\n  get dynamicFormOverride(): string { return this.key; };\n  @Input() set dynamicFormOverride(value: string) {\n    this.key = value;\n    if (this.key && this.key !== '*') {\n      this.meta = this.dynForm.tdmForm.renderData.find( rd => rd.name === value);\n    } else {\n      this.meta = undefined;\n    }\n  };\n\n  /**\n   * A Shortcut for the parent's DynamicFormComponent#.tdmForm.form\n   * @returns\n   */\n  get formGroup(): FormGroup {\n    return this.dynForm.tdmForm.form;\n  }\n\n  /**\n   * Render instruction exposed as an API for templates\n   */\n  meta: RenderInstruction;\n\n  private key: string;\n\n  constructor(\n    public template: TemplateRef<DynamicFormOverrideContext>,\n    @Inject(forwardRef(() => DynamicFormComponent))  private dynForm: DynamicFormComponent<any>\n  ) {}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/@tdm/ngx-dynamic-forms/src/dynamic-forms/dynamic-form-override.directive.ts","import { Observable } from 'rxjs/Observable';\nimport { toPromise } from 'rxjs/operator/toPromise';\n\nimport { RenderInstruction } from '../tdm-model-form/render-instruction';\n\nconst asyncUsed = (done: Promise<void> | Observable<void>) => {\n  throw new Error('async() was already called once.');\n};\n\nexport class BeforeRenderEventHandler {\n  /**\n   * An object whose values are instances of [[RenderInstruction]] and keys are the full static paths of the\n   * [[RenderInstruction]] instance they refer to.\n   */\n  public instructions: { [path: string]: RenderInstruction };\n\n  constructor(instructions: { [path: string]: RenderInstruction },\n              private notify: (done: Promise<void>) => void) {\n    this.instructions = instructions;\n  }\n\n  /**\n   * Mark this render operation as asynchronous, providing a notifier to signal when the rendering can\n   * proceed.\n   *\n   * For example, when a render instruction of type select requires the options of the select to be\n   * fetched from a remote server.\n   *\n   * @param done\n   */\n  async(done: Promise<void> | Observable<void>): void {\n    if (typeof done['then'] === 'function') {\n      this.notify(<any> done);\n    } else if (typeof done['subscribe'] === 'function') {\n      this.notify( toPromise.call(<Observable<void>>done) );\n    } else {\n      throw new Error('Invalid input');\n    }\n    Object.defineProperty(this, 'async', { value: asyncUsed });\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/@tdm/ngx-dynamic-forms/src/dynamic-forms/before-render-event-handler.ts","import {\n  Directive,\n  Input,\n  Type,\n  forwardRef,\n  ViewContainerRef,\n  ComponentFactoryResolver,\n  ComponentRef,\n  Inject,\n  InjectionToken\n} from '@angular/core';\n\nimport { DynamicFormControlRenderer, RenderInstruction } from '../tdm-model-form/index';\nimport { DynamicFormComponent } from './dynamic-form.component';\n\n/**\n * A Token for the component that renders form controls\n */\nexport const FORM_CONTROL_COMPONENT = new InjectionToken<DynamicFormControlRenderer>('DynamicFormControlRenderer');\n\n/**\n * An container/wrapper used to project the user-define renderer.\n * DynamicFormControlDirective is much like `NgComponentOutlet`, they both do the same job.\n *\n * DynamicFormControlDirective is more specific to the use case, it accepts {@link RenderInstruction}\n * as input and renders a component that it get's from the DI.\n * @internal\n */\n@Directive({\n  selector: '[dynamicFormControl]'\n})\nexport class DynamicFormControlDirective {\n\n  get dynamicFormControl(): RenderInstruction {\n    return this.render;\n  }\n\n  @Input() set dynamicFormControl(value: RenderInstruction) {\n    if (this.render === value) {\n      return;\n    }\n    this.render = value;\n\n    this.vcRef.clear();\n\n    if (value) {\n      const injector = this.vcRef.parentInjector;\n      const resolver = injector.get(ComponentFactoryResolver);\n      const componentFactory = resolver.resolveComponentFactory(this.component);\n      const override = this.dynForm.getOverride(value);\n      if (override) {\n        const $implicit: DynamicFormControlRenderer  = <any> {};\n        this.dynForm.tdmForm.bindRenderingData($implicit, value);\n        this.vcRef.createEmbeddedView(\n          override.template, { $implicit } );\n      } else {\n        this.cmpRef = this.vcRef.createComponent<DynamicFormControlRenderer> (\n          componentFactory,\n          this.vcRef.length,\n          injector\n        );\n        this.dynForm.tdmForm.bindRenderingData(this.cmpRef.instance, value);\n        if (typeof this.cmpRef.instance.tdmOnControlContextInit === 'function') {\n          this.cmpRef.instance.tdmOnControlContextInit();\n        }\n      }\n    }\n  }\n\n  private render: RenderInstruction;\n  private cmpRef: ComponentRef<DynamicFormControlRenderer>;\n\n  constructor(private vcRef: ViewContainerRef,\n              @Inject(FORM_CONTROL_COMPONENT) private component: Type<DynamicFormControlRenderer>, // tslint:disable-line\n              @Inject(forwardRef(() => DynamicFormComponent)) public dynForm: DynamicFormComponent<any>) { // tslint:disable-line\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/@tdm/ngx-dynamic-forms/src/dynamic-forms/dynamic-form-control.directive.ts","import { ANALYZE_FOR_ENTRY_COMPONENTS, Type, NgModule, ModuleWithProviders } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { ReactiveFormsModule } from '@angular/forms';\n\nimport { Constructor } from '@tdm/core/tdm';\nimport { DynamicFormControlRenderer, TDMModelFormService, TDMModelFormDirective } from './tdm-model-form/index';\nimport {\n  DynamicFormOverrideDirective,\n  DynamicFormControlDirective,\n  DynamicFormComponent,\n  FORM_CONTROL_COMPONENT\n} from './dynamic-forms/index';\n\n@NgModule({\n  declarations: [\n    TDMModelFormDirective,\n    DynamicFormOverrideDirective, DynamicFormControlDirective, DynamicFormComponent\n  ],\n  imports: [CommonModule, ReactiveFormsModule],\n  exports: [\n    TDMModelFormDirective,\n    DynamicFormOverrideDirective, DynamicFormControlDirective, DynamicFormComponent\n  ]\n})\nexport class DynamicFormsModule {\n  /**\n   * Registers the module with and required services and with the default form control renderer.\n   */\n  static forRoot(formComponent: Type<DynamicFormControlRenderer>): ModuleWithProviders {\n    return {\n      ngModule: DynamicFormsModule,\n      providers: [\n        TDMModelFormService,\n        {\n          provide: ANALYZE_FOR_ENTRY_COMPONENTS,\n          multi: true,\n          useValue: [{component: formComponent}]\n        },\n        {provide: FORM_CONTROL_COMPONENT, useValue: formComponent}\n      ]\n    };\n  }\n\n  /**\n   * Registers the module with the default form control renderer.\n   * Use this when adding to child modules which requires a different renderer.\n   */\n  static forChild(formComponent: Type<DynamicFormControlRenderer>): ModuleWithProviders {\n    return {\n      ngModule: DynamicFormsModule,\n      providers: [\n        {\n          provide: ANALYZE_FOR_ENTRY_COMPONENTS,\n          multi: true,\n          useValue: [{component: formComponent}]\n        },\n        {provide: FORM_CONTROL_COMPONENT, useValue: formComponent}\n      ]\n    };\n  }\n}\n\n/**\n * @deprecated Object renamed, use DynamicFormsModule instead\n */\nexport const TDMFormsModule = DynamicFormsModule;\n/**\n * @deprecated Object renamed, use DynamicFormsModule instead\n */\nexport type TDMFormsModule = Constructor<DynamicFormsModule> & DynamicFormsModule;\n\n\n\n// WEBPACK FOOTER //\n// ./src/@tdm/ngx-dynamic-forms/src/module.ts","module.exports = \"<form #formElRef [formGroup]=\\\"tdmForm.form\\\">\\n    <div *ngFor=\\\"let item of controls | async; trackBy: tdmForm.trackBy\\\"\\n         [ngClass]=\\\"controlClass\\\"\\n         [style.display]=\\\"item.display\\\">\\n      <div>\\n        <ng-container *dynamicFormControl=\\\"item\\\"></ng-container>\\n      </div>\\n    </div>\\n    <ng-content></ng-content>\\n</form>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/@tdm/ngx-dynamic-forms/src/dynamic-forms/dynamic-form.component.html\n// module id = xC36\n// module chunks = 0"],"sourceRoot":"webpack:///"}