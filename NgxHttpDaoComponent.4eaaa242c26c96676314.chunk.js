webpackJsonp([6],{DLzf:function(s,n){s.exports=[{file:"README.md",lang:"md",section:"default",code:'<h1><a id="resource-control" class="anchor" href="#resource-control"><span class="header-link"></span></a>Resource Control</h1><p>A resource represents a domain model with actions. We&#39;ve seen how the\nDAO allows us to invoke these actions on the resource.</p>\n<p>Resource, DAO and Actions, they are all static, metadata that we can use\nto eventually get a resource <strong>instance</strong>.</p>\n<p>Once an action is fired, some questions pop up:</p>\n<ul>\n<li>How do we provision the running action?</li>\n<li>how do we manage the instance? things like<ul>\n<li>The instance state</li>\n<li>controlling a running action (e.g cancel)</li>\n<li>and more..</li>\n</ul>\n</li>\n</ul>\n<p>This is where <code>ResourceControl</code> comes in.</p>\n<p>A <code>ResourceControl</code> instance allow us to control an instance of a\nresource and to listen to notification coming from running actions.</p>\n<p>A single instance of <code>ResourceControl</code> controls a single instance of\na resource. i.e. for every instance of our model a single resource\ncontrol is created.</p>\n<div class="info">\nThe <code>ResourceControl</code> class comes from <code>@tdm/data</code> with a limited set\nof features and a basic event mechanism implementation. \n<br>\n<br>\nPlugins can extend it with additional features, for example\nthe <strong>rx-resource-control</strong> plugin add&#39;s <strong>RxJS</strong> support to\n<code>ResourceControl</code> allowing <code>Observable</code> bases event stream, observable\nstates and more...\n</div>\n\n<h2><a id="getting-the-resource-control" class="anchor" href="#getting-the-resource-control"><span class="header-link"></span></a>Getting the resource control</h2><p>To get a resource control for a resource instance:</p>\n<pre class="lang-ts"><code class="lang-ts"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">this</span>.ngDAO.get(Customer).findById(<span class="hljs-string">\'ALFKI\'</span>);\n<span class="hljs-keyword">const</span> rc = ResourceControl.get(promise);\n\npromise.then( <span class="hljs-function"><span class="hljs-params">resource</span> =&gt;</span> {\n <span class="hljs-comment">// ...</span>\n});\n</code></pre>\n<p>Note that we use the promise returned from the DAO API to track the\nresource control.</p>\n<p><code>ResourceControl.get</code> accepts the promise or the resource instance.\nThe resource instance does not help us, we get it once all is done, so\nwe use the promise.</p>\n<h2><a id="resource-events" class="anchor" href="#resource-events"><span class="header-link"></span></a>Resource Events</h2><p>The <code>ResourceControl</code> comes with the following events:</p>\n<ul>\n<li>ActionStart</li>\n<li>ActionError</li>\n<li>ActionSuccess</li>\n<li>ActionEnd</li>\n<li>ActionCancel</li>\n</ul>\n<p><code>ActionEnd</code> will fire last, when there is not error, i.e. after\n<code>ActionSuccess</code> or <code>ActionCancel</code>.</p>\n<p>When error is thrown, <code>ActionError</code> event is fired but <code>ActionEnd</code> will\nnot follow.</p>\n<p>Resource events has the following base interface:</p>\n<pre class="lang-ts"><code class="lang-ts"><span class="hljs-keyword">interface</span> ResourceEvent {\n  readonly resource: <span class="hljs-built_in">any</span>;\n  readonly <span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span>;\n}\n</code></pre>\n<p>Some errors might extend it, for example the <code>ActionError</code> extends it\nby adding the <strong>error</strong> property.</p>\n<p>You can use the <code>isResourceEvent</code> function to apply the proper type\nto the event:</p>\n<pre class="lang-ts"><code class="lang-ts"><span class="hljs-keyword">import</span> { ResourceControl, isResourceEvent } <span class="hljs-keyword">from</span> <span class="hljs-string">\'@tdm/data\'</span>;\n\n<span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">this</span>.ngDao.get(Customer).findById(<span class="hljs-string">\'ALFKI\'</span>);\npromise.then( <span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(c) );\n\n<span class="hljs-keyword">const</span> rc = ResourceControl.get(promise);\nrc.events$.subscribe(<span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  <span class="hljs-keyword">if</span> (isResourceEvent(<span class="hljs-string">\'ActionError\'</span>, event)) {\n    <span class="hljs-built_in">console</span>.error(event.error);\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-built_in">console</span>.log(event.type);\n  }\n});\n</code></pre>\n<p>The example above will log the entire progress of the action and at\nthe end it will print the result.</p>\n<p><code>promise.then( c =&gt; console.log(c) );</code> will log last.</p>\n<p>We don&#39;t apply a catch statement because we catch the errors within the\nsubscription.</p>\n<p>Notice how we we <code>unsubscribe</code>, this is similar to <strong>RxJS</strong> but it does\nnot the <strong>RxJS</strong> library, it&#39;s is just a similar API.</p>\n<h2><a id="canceling" class="anchor" href="#canceling"><span class="header-link"></span></a>Canceling</h2><p>You can cancel in-flight requests, this is done by calling the <code>cancel()</code>\nmethod.</p>\n',title:"Resource Control"},{file:"customer.ts",lang:"ts",section:"default",code:'<span class="hljs-keyword">import</span> { Identity, Prop } <span class="hljs-keyword">from</span> <span class="hljs-string">\'@tdm/core\'</span>;\n<span class="hljs-keyword">import</span> { ActiveRecord, TypeOfActiveRecord, HttpResource, UrlParam } <span class="hljs-keyword">from</span> <span class="hljs-string">\'@tdm/ngx-http-client\'</span>;\n<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> modelContract <span class="hljs-keyword">from</span> <span class="hljs-string">\'../../server/shared-models\'</span>;\n\n<span class="hljs-meta">@HttpResource</span>({\n  endpoint: <span class="hljs-string">\'customers/:id?\'</span>\n})\n<span class="hljs-keyword">class</span> $Customer <span class="hljs-keyword">extends</span> ActiveRecord() <span class="hljs-keyword">implements</span> modelContract.Customer {\n  <span class="hljs-meta">@Identity</span>()\n  <span class="hljs-meta">@UrlParam</span>(<span class="hljs-string">\'id\'</span>)\n  <span class="hljs-meta">@Prop</span>()\n  CustomerID: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-meta">@Prop</span>()\n  CompanyName: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-meta">@Prop</span>()\n  ContactName: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-meta">@Prop</span>()\n  ContactTitle: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-meta">@Prop</span>()\n  Address: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-meta">@Prop</span>()\n  City: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-meta">@Prop</span>()\n  Region: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-meta">@Prop</span>()\n  PostalCode: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-meta">@Prop</span>()\n  Country: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-meta">@Prop</span>()\n  Phone: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-meta">@Prop</span>()\n  Fax: <span class="hljs-built_in">string</span>;\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Customer: TypeOfActiveRecord&lt;$Customer, <span class="hljs-keyword">typeof</span> $Customer&gt; = &lt;<span class="hljs-built_in">any</span>&gt; $Customer;\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> Customer = ActiveRecord&lt;$Customer&gt;;\n',title:"Model"}]},o6V1:function(s,n){s.exports=[{file:"README.md",lang:"md",section:"default",code:'<h1><a id="data-access-object" class="anchor" href="#data-access-object"><span class="header-link"></span></a>Data Access Object</h1><p>The data access object is a famous design pattern for handling data\nmodels.</p>\n<p>It is the API that maps an instance of a resource to an action and sends\nthem to the <strong>Adapter</strong> for execution.</p>\n<div class="alert">\n<code>@tdm/data</code> comes with an abstract DAO that all adapters must implement,\nsome adapters might extend it.\n</div> \n\n<h2><a id="actions" class="anchor" href="#actions"><span class="header-link"></span></a>Actions</h2><p>An <strong>Action</strong> is a definition for an operation.</p>\n<p>It is similar to angular&#39;s <code>HttpClient</code> where call requires a\nconfiguration. The url, http verb, headers, params, etc...</p>\n<p>In <code>HttpClient</code> each call requires a configuration but <strong>Actions</strong> are\nstatic, they define an action for the resource that does not change.</p>\n<p>You can think of an action as a factory function. When you have the\nsame GET call for all of your models you will probably use a factory\nfunction to execute the <code>HttpClient</code> with some parameters fixed.</p>\n<p>The DAO exposes the actions as methods. Each methods is bound to and\naction and when invoked will bundle the action and the instance and\nsend them to the adapter for processing.</p>\n<div class="info">\nYou can define custom actions on a model or generally available in a\nDAO, we will cover custom actions in future chapters.\n</div>\n\n<h2><a id="getting-the-dao" class="anchor" href="#getting-the-dao"><span class="header-link"></span></a>Getting the DAO</h2><p>You can get the DAO from angular&#39;s DI:</p>\n<pre class="lang-ts"><code class="lang-ts"><span class="hljs-keyword">import</span> { NgDAO } <span class="hljs-keyword">from</span> <span class="hljs-string">\'@tdm/ngx-http-client\'</span>;\n\n<span class="hljs-meta">@Component</span>({\n  selector: <span class="hljs-string">\'ngx-http-dao\'</span>,\n  templateUrl: <span class="hljs-string">\'./dao.component.html\'</span>,\n  styleUrls: [ <span class="hljs-string">\'./dao.component.scss\'</span> ],\n})\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> DaoComponent {\n  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">ngDAO: NgDAO</span>) {\n\n  }\n}\n</code></pre>\n<h2><a id="basic-dao-api" class="anchor" href="#basic-dao-api"><span class="header-link"></span></a>Basic DAO API</h2><p>Let&#39;s look at the DAO API:</p>\n<pre class="lang-ts"><code class="lang-ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HttpDao&lt;T&gt; {\n  query: <span class="hljs-function">(<span class="hljs-params">options?: HttpActionOptions</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;T[]&gt;;\n  findAll: <span class="hljs-function">(<span class="hljs-params">options?: HttpActionOptions</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;T[]&gt;; alias <span class="hljs-keyword">for</span> query\n\n  findById: <span class="hljs-function">(<span class="hljs-params">id: IdentityValueType, options?: HttpActionOptions</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;T&gt;;\n\n  find: <span class="hljs-function">(<span class="hljs-params">options: HttpActionOptions</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;T&gt;;\n  findOne: <span class="hljs-function">(<span class="hljs-params">options: HttpActionOptions</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;T&gt;; <span class="hljs-comment">// alias for find</span>\n\n  create: <span class="hljs-function">(<span class="hljs-params">data: T | Partial&lt;T&gt;, options?: HttpActionOptions</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;T | <span class="hljs-built_in">void</span>&gt;;\n\n  update: <span class="hljs-function">(<span class="hljs-params">data: T | Partial&lt;T&gt;, options?: HttpActionOptions</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;T | <span class="hljs-built_in">void</span>&gt;;\n\n  replace: <span class="hljs-function">(<span class="hljs-params">data: T | Partial&lt;T&gt;, options?: HttpActionOptions</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;T | <span class="hljs-built_in">void</span>&gt;;\n\n  remove: <span class="hljs-function">(<span class="hljs-params"> (<span class="hljs-params">id: IdentityValueType | T, options?: HttpActionOptions</span>) =&gt; <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; </span>);\n}</span>\n</code></pre>\n<p>These are pretty straight forward, they represent the DAO interface\nfor the <code>HttpResource</code> adapter.</p>\n<p>Invoking a <code>GET</code> for the <code>Customer</code> model:</p>\n<pre class="lang-ts"><code class="lang-ts"><span class="hljs-keyword">this</span>.ngDAO.get(Customer).findById(<span class="hljs-string">\'ALFKI\'</span>);\n</code></pre>\n<h3><a id="action-response" class="anchor" href="#action-response"><span class="header-link"></span></a>Action response</h3><p>The DAO API is promise based, every call returns a <code>Promise</code> to a new\ninstance of our model. It is also immutable, a call always return a new\ninstance.</p>\n<p>When an exception is throw, we can catch it by registering a <code>catch</code>\nhandler.</p>\n<h3><a id="action-life-cycle" class="anchor" href="#action-life-cycle"><span class="header-link"></span></a>Action life-cycle</h3><p>The promise API is simple, the life-cycle of an action has only a start\nand an end, which is enough for most use-cases. </p>\n<p>Some scenarios require access to the internal life-cycle hooks, such\nas progress notification.</p>\n<p>We can access these notification through the resource control, which\nis covered in the next chapter. </p>\n<h2><a id="dao-and-active-record" class="anchor" href="#dao-and-active-record"><span class="header-link"></span></a>DAO and Active Record</h2><p>The <strong>ActiveRecord</strong> pattern takes a different approach, each call\nreturns an instance of the model, rather then a <code>Promise</code>.</p>\n<p>The operation is still async, the data will be assigned when it arrive.</p>\n<p>Active record also add actions that we can invoke from the instance\nitself, these will return the <strong>same</strong> instance, updating the instance\nwhen the data arrive.</p>\n<p>When we return an instance we have no idea what happens, when something\narrives and if we had an error in between, we use the resource control\nfor that.</p>\n',title:"DAO"},{file:"customer.ts",lang:"ts",section:"default",code:'<span class="hljs-keyword">import</span> { Identity, Prop } <span class="hljs-keyword">from</span> <span class="hljs-string">\'@tdm/core\'</span>;\n<span class="hljs-keyword">import</span> { ActiveRecord, TypeOfActiveRecord, HttpResource, UrlParam } <span class="hljs-keyword">from</span> <span class="hljs-string">\'@tdm/ngx-http-client\'</span>;\n<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> modelContract <span class="hljs-keyword">from</span> <span class="hljs-string">\'../../server/shared-models\'</span>;\n\n<span class="hljs-meta">@HttpResource</span>({\n  endpoint: <span class="hljs-string">\'customers/:id?\'</span>\n})\n<span class="hljs-keyword">class</span> $Customer <span class="hljs-keyword">extends</span> ActiveRecord() <span class="hljs-keyword">implements</span> modelContract.Customer {\n  <span class="hljs-meta">@Identity</span>()\n  <span class="hljs-meta">@UrlParam</span>(<span class="hljs-string">\'id\'</span>)\n  <span class="hljs-meta">@Prop</span>()\n  CustomerID: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-meta">@Prop</span>()\n  CompanyName: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-meta">@Prop</span>()\n  ContactName: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-meta">@Prop</span>()\n  ContactTitle: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-meta">@Prop</span>()\n  Address: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-meta">@Prop</span>()\n  City: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-meta">@Prop</span>()\n  Region: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-meta">@Prop</span>()\n  PostalCode: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-meta">@Prop</span>()\n  Country: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-meta">@Prop</span>()\n  Phone: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-meta">@Prop</span>()\n  Fax: <span class="hljs-built_in">string</span>;\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Customer: TypeOfActiveRecord&lt;$Customer, <span class="hljs-keyword">typeof</span> $Customer&gt; = &lt;<span class="hljs-built_in">any</span>&gt; $Customer;\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> Customer = ActiveRecord&lt;$Customer&gt;;\n',title:"Model"}]}});
//# sourceMappingURL=NgxHttpDaoComponent.4eaaa242c26c96676314.chunk.js.map